# 第二章

## 运行时内存区域

1. 程序计数器：程序计数器是当前线程所执行的字节码的行号指示器。程序计数器是线程独立的。

2. 栈区：栈区是线程独立的。虚拟机栈描述的是Java方法执行的内存模型，每个方法在执行时都会创建一个栈帧。栈帧中包括局部变量表、操作数栈、动态链接、方法出口等信息。

   - 局部变量表：是一组变量值存储空间，用于存放方法参数和方法内部帝国一的局部变量。
   - 操作数栈：是方法中的指令的工作区，大多数指令都要从栈中弹出数据，执行运算，然后将结果压回栈。
   - 动态链接：指向运行时常量池中当前栈帧所属方法的的引用。持有这个引用是为了支持方法调用过程中的动态链接过程。

3. 堆区：堆区是**所有线程共享**的一块内存区域，在虚拟机启动时就被创建。堆区主要保存**对象实例**和**数组**。

4. 方法区：方法区是**所有线程共享**的一块内存区域。方法区主要保存已被虚拟机加载的类的元信息、常量、静态变量、即时编译器编译后的代码等。

   在JDK1.7之前，HotSpot虚拟机使用永久代实现方法区。JDK1.8之后，HotSpots虚拟机取消了永久代，方法区被拆分，其中方法区保存的类的元信息保存在元空间中，元空间是一个与堆不相连的**本地内存区域**。方法区保存的常量、静态变量保存在堆中。

5. 运行时常量池： 运行时常量池是方法区的一部分，主要用于存放**已加载的Class文件中的常量池**和**运行期产生的常量**。**一个类加载到 JVM 中后对应一个运行时常量池**。

   **Class文件中的常量池中主要包含两大类常量：字面量和符号引用**。

   1. 字面量：字符串常量、声明为final的常量值

   2. 符号引用：包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符

   运行期产生的常量也会进入运行期常量池中。比如String类的intern()方法。当一个String实例str调用intern()方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用。

6. 本地方法区

## 对象的创建过程

1. 检查这个指令的参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载。
2. JVM为新生对象分配内存，即把一块固定大小的内存从JAVA堆中划分出来。指针碰撞法、空闲列表法。
3. 将该对象分配到的内存空间都初始化为零值。（不包括对象头）
4. 将该对象自身的数据（对象类型、哈希码、GC分代年龄、锁状态等）保存到对象头中。
5. 调用<Init>方法完成代码中对象的初始化。

## 对象在内存中的布局

Java对象在内存中的布局有3部分，包括**对象头、实例数据和无意义填充**。

1. 对象头（Mark Word）：对象头的内容包含两部分，第一部分是对象自身的运行时数据，该区域的大小是非固定的。另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
2. 实例数据：即代码中定义的该类各字段的内容，无论是从父类继承来的， 还是该类本身定义的。
3. 无意义填充。

## 对象的访问定位

根据reference指针（即栈中的引用类型数据）中保存的数据的不同，可以分为**使用句柄**和**直接指针**两种方式。

- 使用句柄：JVM在堆中划分出一块内存作为句柄池，而句柄中包含了该对象的实例数据和类型数据的具体地址。reference指针中指向该对象的句柄地址。不使用对象头中的类型指针。
- 直接指针：reference指针中直接存储该对象的具体地址，而对象的对象头中保存对象类型数据的地址。

# 第三章

## JAVA中的4种引用类型

- 强引用：指在程序代码中普遍存在的引用。只要强引用存在，垃圾收集器就不会回收被引用的对象。
- 软引用：指一些有用但非必须的对象。对用软引用关联的对象，只有系统要发生内存溢出时才会回收。
- 弱引用：也指非必要的对象，被弱引用关联的对象只能生存到下一次垃圾收集之前。
- 虚引用：一个对象是否存在虚引用完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象的实例。

## 对象的内存分配策略

1. 大多数情况下，对象在新生代的Eden区中分配。若Eden区中没有足够空间，虚拟机将发起一次MinorGC。
2. 大对象直接进入老年代，避免在Eden区及两个Survivor区之间发生大量的内存复制。
3. 长期存活的对象将进入老年代。
   - JVM为每个对象定义了年龄计数器。对象在Eden区出生时年龄为零，经过一次MinorGC后存活并能被Survivor容纳，则对象年龄加一。当对象的年龄增加到一定程度，就会被移入老年代。
   - 动态对象年龄判定：如果在Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半，则大于或等于该年龄的对象直接进入老年代。
4. Survivor无法容纳的对象直接进入老年代（空间分配担保策略）：因为新生代使用复制收集算法，需要使用其中一个Survivor来作为轮换备份。而当出现大量对象在MinorGC后仍然存活的情况时，就需要老年代进行空间分配担保，使Survivor无法容纳的对象直接进入老年代。

## 垃圾判定算法

### 引用计数法

思路：为对象添加一个引用计数器，每当该对象被引用时计数器加一，当引用失效时计数器减一。计数器为零则证明对象没有被引用，是可回收的。缺点：不能解决对象之间循环引用的问题。

### 可达性分析法

思路：以**GC Roots**对象为起点向下搜索，**当一个对象到GC Roots没有任何路径相连时，该对象是可回收的**。

#### 4种GC Roots对象

- 虚拟机栈中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈（Native方法）中引用的对象。

#### 可达性分析在HotSpot中的实现



### 方法区（永久代）中的垃圾判定

永久代中的垃圾回收主要包括**废弃常量的回收**和**类型的卸载**。

#### 如何判断废弃常量：同样采用可达性分析

#### 如何判断类型无用（要满足3个条件）

- 该类所有的实例都已经被回收，即JAVA堆中不存在该类的任何实例。
- 加载该类的ClassLoader已经被回收。
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 元空间（MetaSpace）中的垃圾回收

每一个类加载器的存储区域都称作一个元空间，所有的元空间合在一起就是我们一直说的元空间。当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。元数据使用达到“MaxMetaspaceSize”参数的设定值时进行




## 垃圾收集算法

为了方便对内存的管理，JVM将堆内存划分为新生代和老年代。其中新生代一般用来存放刚创建的对象，老年代用来存放长期存在的对象。

### 复制算法（用来回收新生代）

将可用内存分为一块较大的Eden空间和两块较小的Survivor空间（8：1），每次只使用Eden和其中一块Survivor空间。当回收时，将Eden和这块Survivor中还存活着的对象一次性的复制到另外一块Survivor上，最后清理掉Eden和刚才用过的Survivor空间。

**分配担保机制**：即如果另外一块Survivor没有足够空间存放存活对象时，这些对象将通过分配担保机制直接进入老年代。

### 标记-清除（用来回收老年代）

该算法分为标记和清除两个阶段。

- 标记阶段：标记出所有需要回收的对象。
- 清除阶段：统一回收所有被标记的对象。

不足：算法会产生大量的不连续内存碎片，容易提前触发另一次的垃圾回收。

### 标记-整理（用来回收老年代）

该算法分为标记和整理两个阶段。

- 标记阶段：标记出所有需要回收的对象。
- 整理阶段：让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

## 垃圾收集器

![âåå¾æ¶éå¨âçå¾çæç´¢ç"æ](https://upload-images.jianshu.io/upload_images/4685968-3a367913acebef67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/707/format/webp)

### Serial收集器(新生代收集器)

采用复制算法。

特点：
1. 采用单线程完成垃圾收集工作。

2. 在进行垃圾收集时，必须暂停其他所有的工作线程，直到收集结束。

### Serial Old收集器（老年代收集器）

Serial Old收集器是采用标记-整理算法的单线程收集器。

### ParNew收集器（新生代收集器）

采用多线程进行垃圾收集，是Serial收集器的多线程版本。
ParNew是运行在Server模式下的虚拟机首选的新生代收集器，因为除了Serial收集器外，只有ParNew能与CMS收集器配合工作。

### Parallel Scavenge收集器（新生代收集器）

Parallel Scavenge收集器采用复制算法。Parallel Scavenge收集器的目标是达到一个可控制的吞吐量。高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。
吞吐量 = 运行用户代码时间 / （运行用户代码时间+垃圾收集时间）。

### Parallel  Old收集器（老年代收集器）

Parallel  Old收集器是采用标记-整理算法的多线程收集器。

### CMS收集器（老年代收集器）

CMS收集器以获取最短回收停顿时间为目的，适用于B/S系统的服务端应用。

CMS收集器采用标记-清除算法。过程包含4个步骤：
- 初始标记：标记GC Roots能直接关联到的对象，速度很快，需要StopTheWorld。
- 并发标记：进行GC Roots Tracing。可以和用户线程一起工作。
- 重新标记：为了修正并发标记期间因用户程序继续运作而导致的标记变动。需要StopTheWorld。
- 并发清除：可以和用户线程一起工作。

缺点：

- CMS收集器对CPU资源敏感。在并发阶段会占用CPU资源而导致应用程序变慢，总吞吐量降低。
- CMS收集器无法处理浮动垃圾。浮动垃圾是指并发清理阶段用户线程产生的垃圾。这部分垃圾产生在标记过程之后，所以当次收集过程无法处理。
- CMS收集器可能导致ConcurrentModeFailure。由于CMS收集器与用户线程并发执行，就需要预留足够的内存空间给用户线程使用。如果CMS运行期间预留内存无法满足需求，就会出现ConcurrentModeFailure失败。此时虚拟机临时启用SerialOld收集器来进行老年代收集。
- CMS收集器采用标记-清除算法，会产生大量内存碎片。此时CMS会进行内存碎片合并。

### G1（Garbage First）收集器（全堆收集器）

G1收集器将整个堆划分为多个大小相等的区域（Region），新生代和老年代都是部分不连续的Region块的集合。

在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。

工作流程：

- 初始标记：用于标记GC Roots能直接关联到的对象，并且修改TAMS的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象。该阶段需要StopTheWorld。
- 并发标记：从GC Roots开始对堆中对象进行可达性分析，找出存活的对象。该阶段耗时时间长，但可以和用户程序并发执行。
- 最终标记：用于修正并发标记期间因用户程序运作而导致标记产生变动的那一部分标记记录，并将变化记录在线程Remenbered Set Logs里面，最后将Remembered Set Logs的数据合并到Remembered Set中。该阶段需要停顿线程，但可以并发执行。
- 筛选回收：对各个Region的回收价值和成本进行排序，并优先回收收益更高（包含可回收的对象更多）的Region。

G1收集器提供了两种GC模式，Young GC和Mixed GC。Young GC用于回收新生代，Mixed GC用于回收新生代和部分收集收益高的若干老年代Region。G1收集器不提供FullGC。

G1收集器同CMS相比的优势：

- G1是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片。
- G1的Stop The World(STW)更可控，G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间。

## MinorGC与FullGC

- MinorGC是指发生在新生代的垃圾收集，当 JVM 无法为一个新的对象分配空间时会触发 Minor GC。

- FullGC是指发生在整个堆上的垃圾收集，包括新生代和老年代。当老年代中最大可用的连续空间小于新生代所有对象总空间时会触发FullGC。



# 第七章

## JVM中类的加载机制

虚拟机的类加载机制是指：JVM把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型的过程。

### 类在JVM中的生命周期
加载、验证、准备、解析、初始化、使用、卸载


### 加载阶段
1. 通过类的全限定名来读取定义该类的二进制流。
2. 将这个二进制流中的代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。（Class类的构造方法是私有的，只有类加载器才能构造Class对象。）

### 准备阶段
准备阶段，为**类变量**分配内存并设置类变量**初始值（数据类型的零值）**，类变量都将在方法区中进行分配。

### 解析阶段

虚拟机规范并未规定解析阶段发生的具体时间。在Class文件中，一个方法对其他方法的调用，或者对成员变量的访问，都是通过符号引用来表示的。解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

- 符号引用：用字符串来表示所引用的对象。
- 直接引用：指向目标地址的指针。

### 初始化阶段
初始化阶段负责对类中所有**类变量赋值（代码定义的值）**和**执行静态语句块中的内容**。父类初始化会先于子类。

#### 什么时候类会被初始化（有且只有5种情况）

1. 使用new关键字实例化对象的时候、读取或设置一个类的(非final修饰的)静态字段的时候、调用一个类的静态方法的时候。
2. 使用java.lang.reflect包的方法对类进行反射调用的时候。
3. 当初始化一个类时，若发现其父类还没有初始化，则需要先对其父类进行初始化。
4. 当jvm启动时，需要先初始化要执行的主类（包含main方法的类）。
5. 使用jdk1.7中的java.lang.invoke.MethodHandle时。


## JVM中的类加载器
  JVM中的所有类加载器都拥有各自独立的类名称空间。也即：比较两个类是否"相等"，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则即使两个类来源于同一个Class文件，且被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类必定不相等。

### 双亲委派模型
从JAVA开发者的角度看，类加载器可以分为3种：
    1. 启动类加载器：负责加载JAVA_HOME\lib目录中或者参数指定的路径中的类库
    2. 扩展类加载器
    3. 应用程序类加载器：负责加载用户类路径上所指定的类库。


![âåäº²å§æ´¾æ¨¡åâçå¾çæç´¢ç"æ](https://images2018.cnblogs.com/blog/1371573/201804/1371573-20180411125544170-1010365637.png)

图中展示的类加载器之间的层次关系称为类加载器的双亲委派模型。双亲委派模型要求除了顶层的启动器加载器外，其余的类加载器都应该有自己的父类加载器。


**双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。 **

双亲委派模型的好处：JAVA类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。

在JDK 9中，虚拟机的类加载器修改为：

1. BootClassLoader：启动类加载器，用于加载启动的基础模块类。
2. PlatformClassLoader：平台类加载器，用于加载一些平台相关的模块，双亲是BootClassLoader。
3. AppClassLoader：应用模块加载器，用于加载应用级别的模块，双亲是PlatformClassLoader



## 实现自定义的类加载器

### 为什么要自定义类加载器

实际工程中有些情况需要自定义类加载器，比如：

1. 加密：Java代码可以轻易的被反编译，为了防止反编译，可以先将编译后的代码加密，而类加密后就不能再用Java的ClassLoader去加载类了，这时就需要自定义ClassLoader在加载类的时候先解密类，然后再加载。

2. 从非标准的来源加载代码：如果你的字节码是放在数据库、甚至是在云端，就可以自定义类加载器，从指定的来源加载类。

3. 实现类的热部署。

### 如何自定义类加载器

继承抽象类ClassLoader，并重写其findClass()方法。

```java
public class MyClassLoader extends ClassLoader {
    public MyClassLoader() {}
    public MyClassLoader(ClassLoader parent) {
        super(parent);
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        File file = new File("E:\\JAVA\\JAVA\\src\\com\\xu\\People.class");
        try {
            byte[] bytes = getClassBytes(file); //自定义的方法，以字节流的方式读入一个class文件
            //将二进制流字节文件转换为一个java.lang.Class对象
            return this.defineClass(name, bytes, 0, bytes.length);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return super.findClass(name);
    }
    public static void main(String[] args) throws Exception, {
        MyClassLoader mcl = new MyClassLoader();
        Class<?> clazz = Class.forName("com.xu.People", true, mcl);
        Object obj = clazz.getDeclaredConstructor().newInstance();
        System.out.println(obj);
        System.out.println(obj.getClass().getClassLoader());//打印出我们的自定义类加载器
    }
}
```

# 第八章

## 方法调用过程版本的确定

方法调用并不等于方法执行，方法调用阶段唯一的任务就是确定被调用方法的调用版本（即调用哪一个方法），不涉及方法内部的具体运行过程。由于在Class文件中，对方法的调用都只是符号引用



类加载阶段的方法调用

在类加载的解析阶段，会将可确定调用版本，且调用版本在运行期不会改变的方法调用的符号引用转化为直接引用。这些方法包括静态方法、私有方法、实例构造器、父类方法等。

解析调用是一个静态的过程，在编译期间就会完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。





分派



