## 分布式事务

### 1. CAP理论
一个分布式系统不可能同时满足一致性、可用性和分区容错性这三个基本需求，最多只能同时满足其中的两项。
- 一致性：指数据在多个副本之间是否能够保持一致的特性。
- 可用性：指系统提供的服务必须一直处于可用的状态，对于用户的每个请求总是能够在有限的时间内返回结果。
- 分区容错性：指分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境故障。（分区容错性必须要保证）

### 2. BASE理论

BASE是基本可用、软状态、最终一致性的缩写。BASE理论是对CAP中一致性和可用性权衡的结果。其核心思想是即使无法做到强一致性，但每个应用都可以根据自身的特点，采用适当的方式使系统达到最终一致性。

- 基本可用： 指分布式系统在出现不可预知的故障时，允许损失部分可用性。
- 软状态：指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性。即允许系统在不同节点的数据副本间进行数据同步的过程存在延时。
- 最终一致性：指系统中所有的数据副本，在经过一段时间的同步后，最终能达到一个一致的状态。最终一致性主要有五种：
  - 因果一致性：
  - 读已之所写：
  - 会话一致性：
  - 单调读一致性：
  - 单调写一致性：

## 一致性协议（为了解决分布式一致性问题）

在分布式系统中，当一个事务操作需要跨越多个节点的时候，就需要引入“协调者”组件来统一调度所有分布式节点的执行逻辑，而被调度的分布式节点则被称为“参与者”。

###  二阶段提交协议（2PC）
将事务的提交过程分为两个阶段。
  - 阶段一：投票阶段(prepare)
     1. 协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，并等待参与者的响应。
     2. 各参与者执行事务操作，并将UNDO和REDO信息记入事务日志。
     3. 如果参与者成功执行了事务操作，就反馈给协调者YES响应。否则就反馈NO响应。

  - 阶段二：执行阶段：在该阶段，协调者会根据各参与者的反馈来决定是否可以进行事务提交。一般包含两种情况：

        -  提交事务：当协调者从所有参与者获得的反馈都是YES响应。
            1. 协调者向所有参与者发送Commit请求。
            2. 参与者收到Commit请求后，正式进行事务提交操作。并在完成后向协调者发送ACK消息。
            3. 协调者收到所有参与者的ACK响应后，完成事务提交。
      -  中断事务：当有参与者向协调者反馈了NO响应；或超时之前，协调者没有收到所有参与者的反馈。
           1. 协调者向所有参与者发送ROLLBACK请求。
           2. 参与者收到ROLLBACK请求后，根据UNDO信息执行事务回滚操作。并在完成后向协调者发送ACK消息。
           3. 协调者收到所有参与者发送的ACK消息后，完成事务中断.

#### 2PC的缺点

- 同步阻塞：在2PC的执行过程中，各个参与者在等待其他参与者响应的时侯，无法进行其他任何操作。
- 单点问题：协调者的单点问题。尤其是当协调者在阶段二中出现问题。
- 数据不一致：当协调者向参与者发送Commit请求时出现网络异常。
- 没有容错机制：

### Mysql中的2pc

MySQL两阶段提交中的角色主要包括：协调者和参与者。协调者也称为是事务管理器，即MySQL客户端，它负责发起事务，并协调分布式事务在各个DB上的执行。参与者即MySQL服务器，也称资源管理器。在实际的应用中，分布式事务需要首先确定事务的参与者，然后主要步骤如下：

步骤1：协调者向所有的参与者发起prepare，所有参与者根据自身情况，向协调者返回prepare的状态，Ready or Not ? 

步骤2：若有参与者返回Not状态，则协调者放弃本次事务，所有参与者Rollback已操作的内容。否则所有参与者执行commit操作。

XA 将事务的提交分为两个阶段，而这种实现，解决了 binlog 和 redo log的一致性问题，这就是MySQL内部XA的第三种功能。

MySQL为了兼容其它非事物引擎的复制，在server层面引入了 binlog, 它可以记录所有引擎中的修改操作，因而可以对所有的引擎使用复制功能；MySQL在4.x 的时候放弃redo的复制策略而引入binlog的复制(淘宝丁奇)。

但是引入了binlog，会导致一个问题——binlog和redo log的一致性问题：一个事务的提交必须写redo log和binlog，那么二者如何协调一致呢？事务的提交以哪一个log为标准？如何判断事务提交？事务崩溃恢复如何进行？

MySQL通过**两阶段提交**(**内部XA的两阶段提交**)很好地解决了这一问题：

**第一阶段：**InnoDB prepare，持有prepare_commit_mutex，并且write/sync redo log； 将回滚段设置为Prepared状态，binlog不作任何操作；

**第二阶段：**包含两步，1> write/sync Binlog； 2> InnoDB commit (写入COMMIT标记后释放prepare_commit_mutex)；

以 binlog 的写入与否作为事务提交成功与否的标志，innodb commit标志并不是事务成功与否的标志。因为此时的事务崩溃恢复过程如下：

1> 崩溃恢复时，扫描最后一个Binlog文件，提取其中的xid； 
2> InnoDB维持了状态为Prepare的事务链表，将这些事务的xid和Binlog中记录的xid做比较，如果在Binlog中存在，则提交，否则回滚事务。

通过这种方式，可以让InnoDB和Binlog中的事务状态保持一致。如果在写入innodb commit标志时崩溃，则恢复时，会重新对commit标志进行写入；

在prepare阶段崩溃，则会回滚，在write/sync binlog阶段崩溃，也会回滚。这种事务提交的实现是MySQL5.6之前的实现。





### 三阶段提交（3PC）
- 阶段一：投票阶段
	  1. 协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，并等待参与者的响应。
	  2. 参与者如果其自身认为可以顺利执行事务，则反馈YES响应。否则反馈NO响应。

- 阶段二：预提交阶段：在该阶段，协调者会根据各参与者的反馈来决定是否可以进行事务PreCommit。一般包含两种情况：
  -	执行事务预提交：当协调者从所有参与者获得的反馈都是YES响应。
	  1. 协调者向所有参与者发送preCommit请求，并进入prepared阶段。
	  2. 各参与者执行事务操作，并将UNDO和REDO信息记入事务日志。
	  3. 如果参与者成功执行了事务操作，就反馈给协调者ACK响应。 
  -	中断事务：当有参与者向协调者反馈了NO响应；或超时之前，协调者没有收到所有参与者的反馈。
	  1. 协调者向所有参与者发送abort请求。
	  2. 参与者收到abort请求，或在等待过程中出现超时，参与者都会中断事务。

- 阶段三：提交阶段：该阶段将进行真正的事务提交，存在两种情况。
  - 执行提交 
	  1. 协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。
	  2. 参与者接收到doCommit请求之后，执行正式的事务提交。事务提交完之后，向协调者发送Ack响应。
	  3. 协调者接收到所有参与者的ack响应之后，完成事务。
    
  - 中断事务：协调者没有接收到参与者发送的ACK响应，那么就会执行中断事务。
	  1. 协调者向所有参与者发送abort请求。
	  2. 参与者接收到abort请求之后，利用undo信息来执行事务的回滚操作。并在完成事务回滚之后，向协调者发送ACK消息。
	  3. 协调者接收到参与者反馈的ACK消息之后，中断事务。

### 2PC与3PC的区别

相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。

#### 3PC的缺点

3PC也存在数据一致性问题，因为由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。

3PC为什么比2PC好？
直接分析协调者和参与者都挂的情况。

第二阶段协调者和参与者挂了，挂了的这个参与者在挂之前已经执行了操作。但是由于他挂了，没有人知道他执行了什么操作。

这种情况下，当新的协调者被选出来之后，他同样是询问所有的参与者的情况来觉得是commit还是roolback。这看上去和二阶段提交一样啊？他是怎么解决一致性问题的呢？

看上去和二阶段提交的那种数据不一致的情况的现象是一样的，但仔细分析所有参与者的状态的话就会发现其实并不一样。我们假设挂掉的那台参与者执行的操作是commit。那么其他没挂的操作者的状态应该是什么？他们的状态要么是prepare-commit要么是commit。因为3PC的第三阶段一旦有机器执行了commit，那必然第一阶段大家都是同意commit。所以，这时，新选举出来的协调者一旦发现未挂掉的参与者中有人处于commit状态或者是prepare-commit的话，那就执行commit操作。否则就执行rollback操作。这样挂掉的参与者恢复之后就能和其他机器保持数据一致性了。（为了简单的让大家理解，笔者这里简化了新选举出来的协调者执行操作的具体细节，真实情况比我描述的要复杂）

简单概括一下就是，如果挂掉的那台机器已经执行了commit，那么协调者可以从所有未挂掉的参与者的状态中分析出来，并执行commit。如果挂掉的那个参与者执行了rollback，那么协调者和其他的参与者执行的肯定也是rollback操作。

所以，再多引入一个阶段之后，3PC解决了2PC中存在的那种由于协调者和参与者同时挂掉有可能导致的数据一致性问题。

### TCC事务
TCC是通过（由业务系统提供的）业务逻辑的调度来实现分布式事务。TCC将一个分布式事务分为三个阶段，分别对应Try、Confirm和Cancel三种操作，这三种操作的业务含义如下：

- Try：尝试执行业务。
  - 完成所有业务检查(一致性)
  - 预留必须业务资源(准隔离性)

- Confirm：确认执行业务。
  - 真正执行业务
  - 不做任何业务检查
  - 只使用Try阶段预留的业务资源

- Cancel：取消执行业务
  - 释放Try阶段预留的业务资源

一个完整的TCC事务参与方包括三部分：

- 主业务服务：主业务服务为整个业务活动的发起方，如前面提到的组合支付场景，支付系统即是主业务服务。
- 从业务服务：从业务服务负责提供TCC业务操作，是整个业务活动的操作方。从业务服务必须实现Try、Confirm和Cancel三个接口，供主业务服务调用。由于Confirm和Cancel操作可能被重复调用，故要求Confirm和Cancel两个接口必须是幂等的。前面的组合支付场景中的余额系统和红包系统即为从业务服务。
- 业务活动管理器：业务活动管理器管理控制整个业务活动，包括记录维护TCC全局事务的事务状态和每个从业务服务的子事务状态，并在业务活动提交时确认所有的TCC型操作的confirm操作，在业务活动取消时调用所有TCC型操作的cancel操作。

####  一个案例理解

账务拆分的业务场景如下，分别位于三个不同分库的帐户A、B、C，然后A和B一起向C转帐共80元。

1、Try：尝试执行业务。

- 完成所有业务检查(一致性)：检查A、B、C的帐户状态是否正常，帐户A的余额是否不少于30元，帐户B的余额是否不少于50元。
- 预留必须业务资源(准隔离性)：帐户A的冻结金额增加30元，帐户B的冻结金额增加50元，这样就保证不会出现其他并发进程扣减了这两个帐户的余额而导致在后续的真正转帐操作过程中，帐户A和B的可用余额不够的情况。


2、Confirm：确认执行业务。

- 释放Try阶段预留的业务资源：如果Try阶段部分成功，比如帐户A的余额够用，且冻结相应金额成功，帐户B的余额不够而冻结失败，则需要对帐户A做Cancel操作，将帐户A被冻结的金额解冻掉。

TCC事务的优点如下：

- 解决了跨应用业务操作的原子性问题，在诸如组合支付、账务拆分场景非常实用。
- TCC实际上把数据库层的二阶段提交上提到了应用层来实现，对于数据库来说是一阶段提交，规避了数据库层的2PC性能低下问题。

TCC事务的缺点，主要就一个：

- TCC的Try、Confirm和Cancel操作功能需业务提供，开发成本高。