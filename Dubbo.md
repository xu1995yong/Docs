## 为什么使用Dubbo



## 完整的RPC同步调用流程

1. 服务消费方（client）以本地调用方式调用服务；
2. client stub（客户端存根）接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体； 
3. client stub找到服务地址，并将消息发送到服务端；
4. server stub收到消息后进行解码； 
5. server stub根据解码结果调用本地的服务； 
6. 本地服务执行并将结果返回给server stub； 
7. server stub将返回结果打包成消息并发送至消费方； 
8. client stub接收到消息，并进行解码； 
9. 服务消费方得到最终结果。



## Dubbo的架构

![dubbo-architucture](http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-architecture.jpg)

### 节点角色说明

| 节点        | 角色说明                               |
| ----------- | -------------------------------------- |
| `Provider`  | 暴露服务的服务提供方                   |
| `Consumer`  | 调用远程服务的服务消费方               |
| `Registry`  | 服务注册与发现的注册中心               |
| `Monitor`   | 统计服务的调用次数和调用时间的监控中心 |
| `Container` | 服务运行容器                           |

### Dubbo启动流程

1. 服务容器负责启动，加载，运行服务提供者。
2. 服务提供者在启动时，向注册中心注册自己提供的服务。 向 `/dubbo/XXXService/providers` 目录下写入自己的 URL 地址。
3. 服务消费者在启动时，向注册中心订阅自己所需的服务。订阅 `/dubbo/XXXService/providers` 目录下的提供者 URL 地址。并向 `/dubbo/XXXService/consumers` 目录下写入自己的 URL 地址
4. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
5. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
6. 监控中心启动时: 订阅 `/dubbo/XXXService` 目录下的所有提供者和消费者 URL 地址。服务消费者和提供者定时每分钟发送一次统计数据到监控中心。

### Dubbo 架构的特点

#### 连通性

- 注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小
- 监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示
- 服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销
- 服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销
- 注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外
- 注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者
- 
- 注册中心和监控中心都是可选的，服务消费者可以直连服务提供者

#### 健壮性

- 监控中心宕掉不影响使用，只是丢失部分采样数据
- 数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务
- 注册中心对等集群，任意一台宕掉后，将自动切换到另一台
- 注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯，或者通过直连的方式通信
- 服务提供者无状态，任意一台宕掉后，不影响使用
- 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复

#### 伸缩性

- 注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心
- 服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者



## Dubbo中的协议

### dubbo协议

Dubbo 缺省协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。但Dubbo 缺省协议不适合传送大数据量的服务，比如传文件，传视频等。

**特性**

- 连接个数：单连接
- 连接方式：长连接
- 传输协议：TCP
- 传输方式：NIO 异步传输
- 序列化：Hessian 二进制序列化
- 适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用 dubbo 协议传输大文件或超大字符串。
- 适用场景：常规远程服务方法调用



### http协议

基于 HTTP 表单的远程调用协议，采用 Spring 的 HttpInvoker 实现。

**特性**

- 连接个数：多连接
- 连接方式：短连接
- 传输协议：HTTP
- 传输方式：同步传输
- 序列化：表单序列化
- 适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。
- 适用场景：需同时给应用程序和浏览器 JS 使用的服务。



### rmi协议

RMI 协议采用 JDK 标准的 `java.rmi.*` 实现，采用阻塞式短连接和 JDK 标准序列化方式。

注意：如果正在使用 RMI 提供服务给外部访问 [[1\]](http://dubbo.apache.org/zh-cn/docs/user/references/protocol/rmi.html#fn1)，同时应用里依赖了老的 common-collections 包 [[2\]](http://dubbo.apache.org/zh-cn/docs/user/references/protocol/rmi.html#fn2) 的情况下，存在反序列化安全风险 [[3\]](http://dubbo.apache.org/zh-cn/docs/user/references/protocol/rmi.html#fn3)。

**特性**

- 连接个数：多连接
- 连接方式：短连接
- 传输协议：TCP
- 传输方式：同步传输
- 序列化：Java 标准二进制序列化
- 适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。
- 适用场景：常规远程服务方法调用，与原生RMI服务互操作







## Dubbo中的注册中心

注册中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表

### Zookeeper注册中心

支持以下功能：

- 当提供者出现断电等异常停机时，注册中心能自动删除提供者信息
- 当注册中心重启时，能自动恢复注册数据，以及订阅请求
- 当会话过期时，能自动恢复注册数据，以及订阅请求
- 当设置 `<dubbo:registry check="false" />` 时，记录失败注册和订阅请求，后台定时重试
- 可通过 `<dubbo:registry username="admin" password="1234" />` 设置 zookeeper 登录信息
- 可通过 `<dubbo:registry group="dubbo" />` 设置 zookeeper 的根节点，不设置将使用无根树
- 支持 `*` 号通配符 `<dubbo:reference group="*" version="*" />`，可订阅服务的所有分组和所有版本的提供者







## Dubbo中的负载均衡

### 基于权重的随机负载均衡（Random ）

- 按权重设置随机概率。
- 在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。

### 基于轮询的负载均衡（RoundRobin ）

- 按公约后的权重设置轮询比率。
- 存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。

### 基于最少活跃数的负载均衡（LeastActive ）

- **最少活跃调用**，相同活跃数的随机，活跃数指调用前后计数差。
- 越快的提供者收到的请求越多，越慢的提供者收到的请求越少，因为越慢的提供者的调用前后计数差会越大。

### 基于一致性 Hash的负载均衡（ConsistentHash ）

- 相同参数的请求总是发到同一提供者。
- 当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。
- 算法参见：<http://en.wikipedia.org/wiki/Consistent_hashing>
- 缺省只对第一个参数 Hash，如果要修改，请配置 `<dubbo:parameter key="hash.arguments" value="0,1" />`
- 缺省用 160 份虚拟节点，如果要修改，请配置 `<dubbo:parameter key="hash.nodes" value="320" />`



## Dubbo中的集群容错

在集群调用失败时，Dubbo 提供了多种容错方案。

### Failover Cluster

失败自动切换，当出现失败，重试其它服务器 [[1\]](https://dubbo.incubator.apache.org/zh-cn/docs/user/demos/fault-tolerent-strategy.html#fn1)。通常用于读操作，但重试会带来更长延迟。可通过 `retries="2"` 来设置重试次数(不含第一次)。

### Failfast Cluster

快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。

### Failsafe Cluster

失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。

### Failback Cluster

失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。

### Forking Cluster

并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 `forks="2"` 来设置最大并行数。

### Broadcast Cluster

广播调用所有提供者，逐个调用，任意一台报错则报错 [[2\]](https://dubbo.incubator.apache.org/zh-cn/docs/user/demos/fault-tolerent-strategy.html#fn2)。通常用于通知所有提供者更新缓存或日志等本地资源信息。





 

 

6 dubbo中的rpc如何实现。

1、dubbo几个协议的对比，dubbo的底层实现（从这里扯到了netty，socket，三次握手， 

2、dubbo的服务注册过程，服务调用过程，讲一讲底层怎么实现的。（面到这里我基本知道我凉了。。）



5、rpc的调用过程？dubbo的服务调用过程？基本组件？dubbo各协议的区别？（dubbo协议基于tcp，又扯到了tcp与udp的区别）

 

 

Dubbo完整的一次调用链路介绍；

 

Dubbo Provider服务提供者要控制执行并发请求上限，具体怎么做？

Dubbo启动的时候支持几种配置方式？

**dubbo：**

底层原理，通信机制，缓存列表，dubbo的重试机制的各种区别，使用场景，如何选择，dubbo的负载均衡策略的各种比对，

现场写了一段随机加权的源码分析给面试官看，dubbo的spi机制等问题。

2、Dubbo 注册中心怎么实现，zookeeper了解吗，介绍下，zookeeper持久化节点和临时节点，注册中心怎么与服务方保持心跳的









