## Java中长度为0的数组与null的区别
有如下两个变量定义：
​	
​	1 int[] zero = new int[0];    
​	2 int[] nil = null; 

这两种定义有什么区别呢？
 zero是一个长度为0的数组，我们称之为“空数组”，空数组也是一个对象，只是包含元素个数为0。    
 null是一个数组类型的空引用。

## 关于Set中的两个toArray()方法理解

	Object[] toArray() // 返回一个包含 set 中所有元素的数组。
	<T> T[]	toArray(T[] a) //返回一个包含此 set 中所有元素的数组；返回数组的运行时类型是指定数组的类型。

对于Set而言，它只知道它内部保存的是Object，所以默认情况下，toArray只能是返回一个由这些Object构成的Object数组出来。但程序的作者或许更清楚其内部元素的更具体的类型，因此，HashSet类提供了toArray的另一个重载版本，允许用户指定一种比Object[]更具体的数组类型，方法是传递一个用户想要的数组类型的一个数组实例进去，多长都无所谓（因此我们常常使用一个0长度的，毕竟把类型带进去就OK了），于是，toArray内部就会按照你想要的这种类型，给构造一个数组出来。这样构造出来的数组，当然是很安全地被调用者转换回那个实际的类型。

--------

报错：Implicit super constructor Person() is undefined. Must explicitly invoke another constructor

我们假设A是B的父类，B是A的子类。 
1、如果程序员没有给类A没有提供构造函数，则编译器会自动提供一个默认的无参数的构造函数，如果用户提供了自己的构造函数，则编译器就不在提供默认的无参数构造函数。 
2、子类B实例化时会自动调用父类A的默认构造函数，所以如果A的默认的无参数的构造函数为private，则编译器会报错，而如果A没有提供默认的无参数的构造函数，而提供了其他类型的构造函数，编译器同样会报错，因为B找不到A的默认无参数构造函数。所以，我们最好给父类A提供一个无参数的构造函数。 
3、或者在B的构造函数中显示的调用父类A的有参构造函数。super（parameter）

## JAVA中的异常体系

Throwable类是所有异常或错误的超类，它有两个子类：Error和Exception，分别表示错误和异常。其中异常Exception分为运行时异常(RuntimeException)和非运行时异常，也称之为不检查异常(Unchecked Exception)和检查异常(Checked Exception)。

Java的异常(包括Exception和Error)分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）。
可查异常（编译器要求必须处置的异常）：正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。
除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。
不可查异常(编译器不要求强制处置的异常):包括运行时异常（RuntimeException与其子类）和错误（Error）。

如果使用throw在方法体中抛出可查异常比如：InterruptedException，则需要在方法头部声明方法可能抛出的异常类型。程序会在throw语句后立即终止，它后面的语句执行不到，然后在包含它的所有try块中（可能在上层调用函数中）从里向外寻找含有与其匹配的catch子句的try块。



5.运行时异常和非运行时异常

(1)运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。

当出现RuntimeException的时候，我们可以不处理。当出现这样的异常时，总是由虚拟机接管。比如：我们从来没有人去处理过NullPointerException异常，它就是运行时异常，并且这种异常还是最常见的异常之一。 
出现运行时异常后，如果没有捕获处理这个异常（即没有catch），系统会把异常一直往上层抛，一直到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，这个线程也就退出了。如果是主程序抛出的异常，那么这整个程序也就退出了。运行时异常是Exception的子类，也有一般异常的特点，是可以被catch块处理的。只不过往往我们不对他处理罢了。也就是说，你如果不对运行时异常进行处理，那么出现运行时异常之后，要么是线程中止，要么是主程序终止。 
如果不想终止，则必须捕获所有的运行时异常，决不让这个处理线程退出。队列里面出现异常数据了，正常的处理应该是把异常数据舍弃，然后记录日志。不应该由于异常数据而影响下面对正常数据的处理。


(2)非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。如IOException、SQLException等以及用户自定义的Exception异常。对于这种异常，JAVA编译器强制要求我们必需对出现的这些异常进行catch并处理，否则程序就不能编译通过。所以，面对这种异常不管我们是否愿意，只能自己去写一大堆catch块去处理可能的异常。



## 内部类

### 静态内部类

只有内部类可以声明为static，外部类声明为static会报错。

##### 静态内部类 VS 普通内部类

1. 静态内部类只能访问外部类的静态成员变量和方法， 普通内部类可以访问外部类的任意成员变量和方法。
2. 静态内部类可以声明任意类型的成员变量和方法，普通内部类不能声明静态的成员变量，除非用final修饰。普通内部类不能声明静态方法。
3. 静态内部类可以单独初始化，普通内部类初始化时必须先初始化外部类。



### 匿名内部类

##### 匿名内部类访问外部类方法中的局部变量

   匿名内部类不能访问外部类方法中的局部变量，除非变量被声明为final类型

1. 这里所说的“匿名内部类”主要是指在其外部类的成员方法内定义，同时完成实例化的类，若其访问成员方法中的局部变量，局部变量必须要被final修饰。
2. 原因是编译程序实现上的困难：内部类对象的生命周期会超过局部变量的生命周期。局部变量的生命周期：当该方法被调用时，该方法中的局部变量在栈中被创建，当方法调用结束时，退栈，这些局部变量全部死亡。而内部类对象生命周期与其它类一样：自创建一个匿名内部类对象，系统为该对象分配内存，直到没有引用变量指向分配给该对象的内存，它才会死亡(被JVM垃圾回收)。所以完全可能出现的一种情况是：成员方法已调用结束，局部变量已死亡，但匿名内部类的对象仍然活着。
3. 如果匿名内部类的对象访问了同一个方法中的局部变量，就要求只要匿名内部类对象还活着，那么栈中的那些它要所访问的局部变量就不能“死亡”。
4. 解决方法：匿名内部类对象可以访问同一个方法中被定义为final类型的局部变量。定义为final后，编译程序的实现方法：对于匿名内部类对象要访问的所有final类型局部变量，都拷贝成为该对象中的一个数据成员。这样，即使栈中局部变量已死亡，但被定义为final类型的局部变量的值永远不变，因而匿名内部类对象在局部变量死亡后，照样可以访问final类型的局部变量，因为它自己拷贝了一份，且与原局部变量的值始终一致。



