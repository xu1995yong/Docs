# 设计模式

软件工程中，针对某些场景、某类问题的某种通用的解决方案。

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170928225241215-295252070.png)



## 单例模式

饿汉式在Class文件加载时就创建实例，所以创建实例的过程是安全的。但是饿汉式的创建方式在 Singleton 实例的创建需要依赖配置文件的情况下是无法使用的。

### 懒汉式-双重检验锁
#### 为什么需要volatile

因为实例化对象的代码实际上可以分解为三个步骤：

1. 分配内存空间
2. 初始化对象
3. 将对象指向刚分配的内存空间

但是有些编译器为了性能的原因，可能会将第二步和第三步进行重排序，顺序就成了：
1. 分配内存空间
2. 将对象指向刚分配的内存空间
3. 初始化对象

现在考虑重排序后，两个线程发生了以下调用：

| Time | Thread A                        | Thread B                                        |
| :--- | :------------------------------ | :---------------------------------------------- |
| T1   | 检查到`uniqueSingleton`为空     |                                                 |
| T2   | 获取锁                          |                                                 |
| T3   | 再次检查到`uniqueSingleton`为空 |                                                 |
| T4   | 为`uniqueSingleton`分配内存空间 |                                                 |
| T5   | 将`uniqueSingleton`指向内存空间 |                                                 |
| T6   |                                 | 检查到`uniqueSingleton`不为空                   |
| T7   |                                 | 访问`uniqueSingleton`（此时对象还未完成初始化） |
| T8   | 初始化`uniqueSingleton`         |                                                 |

在这种情况下，T7时刻线程B对`uniqueSingleton`的访问，访问的是一个**初始化未完成**的对象

```java

volatile private static MySingleton instance = null;   //使用volatile关键字保证其可见性
private MySingleton() { //构造方法私有化
}
public static MySingleton getInstance() {
    if (instance == null) { //第一次检查，只有当instance检查没有初始化时，才加锁
        synchronized (MySingleton.class) {
            if (instance == null) {//二次检查，为什么需要二次检查：比如有两个线程同时到了synchronized代码块，然后第一个线程获取锁成功，对instance进行初始化，之后第一个线程退出synchronized代码块。这样第二个线程就进入了synchronized代码块，这时如果不对instance进行第二次判断的话，就会再一次对其初始化，导致单例失败。
                instance = new MySingleton();
            }
        }
    }
    return instance;
}
```

### 懒汉式-枚举

枚举类的加载过程是线程安全的，可通过此特性构造线程安全的单例

```java
//构造单例
public class ClassFactory {
    private enum MyEnumSingleton {
        singletonFactory; //该枚举类的实例
        private Person instance; //每个枚举类都有的字段
        MyEnumSingleton() {//枚举类的构造方法在类加载是被实例化
            instance = new Person();
        }
        public Person getInstance() {
            return instance;
        }
    }
    public static Person getInstance() {
        return MyEnumSingleton.singletonFactory.getInstance();
    }
}
//获取单例
Object object = ClassFactory.getInstance()
```

## 策略模式

当实现某一个功能存在多种算法或者策略，如果使用多重条件转移语句实现（即硬编码），不但使条件语句变得很复杂，而且增加、删除或更换算法会违背开闭原则。如果采用策略模式就能很好解决该问题。  

策略模式的主要优点如下。

1. 多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。
2. 策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。
3. 策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。
4. 策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。
5. 策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。

其主要缺点如下。

1. 客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。
2. 策略模式造成很多的策略类。

### 模式的结构

策略模式的主要角色如下：

1. 抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。
2. 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。
3. 环境（Context）类：持有一个策略类的引用，最终给客户端调用。

```java
interface Strategy {//抽象策略接口
    public void strategyMethod();    //策略方法
}
//具体策略类A
class ConcreteStrategyA implements Strategy {
    public void strategyMethod() {
        System.out.println("具体策略A的策略方法被访问！");
    }
}
//具体策略类B
class ConcreteStrategyB implements Strategy {
    public void strategyMethod() {
        System.out.println("具体策略B的策略方法被访问！");
    }
}
//环境类
class Context {
    private Strategy strategy;
    public Strategy getStrategy() {
        return strategy;
    }
    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }
    public void strategyMethod() {
        strategy.strategyMethod();
    }
}
```

### 策略模式的扩展

在一个使用策略模式的系统中，当存在的策略很多时，客户端管理所有策略算法将变得很复杂，如果在环境类中使用策略工厂模式来管理这些策略类将大大减少客户端的工作复杂度，

![ç­ç¥å·¥åæ¨¡å¼çç»æå¾](http://c.biancheng.net/uploads/allimg/181116/3-1Q116104010550.gif)

## Spring中常用的设计模式


**第一种：简单工厂**

又叫做静态工厂方法（StaticFactory Method）模式，但不属于23种GOF设计模式之一。 
简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。 
spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。如下配置，就是在 HelloItxxz 类中创建一个 itxxzBean。

 


**第二种：工厂方法（Factory Method）**



通常由应用程序直接使用new创建新的对象，为了将对象的创建和使用相分离，采用工厂模式,即应用程序将对象的创建及初始化职责交给工厂对象。

一般情况下,应用程序有自己的工厂对象来创建bean.如果将应用程序自己的工厂对象交给Spring管理,那么Spring管理的就不是普通的bean,而是工厂Bean。

螃蟹就以工厂方法中的静态方法为例讲解一下：

 

**第三种：单例模式（Singleton）**

保证一个类仅有一个实例，并提供一个访问它的全局访问点。 
spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为spring管理的是是任意的java对象。 


**第四种：适配器（Adapter）**

在Spring的Aop中，使用的Advice（通知）来增强被代理类的功能。Spring实现这一AOP功能的原理就使用代理模式（1、JDK动态代理。2、CGLib字节码生成技术代理。）对类进行方法级别的切面增强，即，生成被代理类的代理类， 并在代理类的方法前，设置拦截器，通过执行拦截器重的内容增强了代理方法的功能，实现的面向切面编程。






**第五种：包装器（Decorator）**

在我们的项目中遇到这样一个问题：我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。我们以往在spring和hibernate框架中总是配置一个数据源，因而sessionFactory的dataSource属性总是指向这个数据源并且恒定不变，所有DAO在使用sessionFactory的时候都是通过这个数据源访问数据库。但是现在，由于项目的需要，我们的DAO在访问sessionFactory的时候都不得不在多个数据源中不断切换，问题就出现了：如何让sessionFactory在执行数据持久化的时候，根据客户的需求能够动态切换不同的数据源？我们能不能在spring的框架下通过少量修改得到解决？是否有什么设计模式可以利用呢？ 
首先想到在spring的applicationContext中配置所有的dataSource。这些dataSource可能是各种不同类型的，比如不同的数据库：Oracle、SQL Server、MySQL等，也可能是不同的数据源：比如apache 提供的org.apache.commons.dbcp.BasicDataSource、spring提供的org.springframework.jndi.JndiObjectFactoryBean等。然后sessionFactory根据客户的每次请求，将dataSource属性设置成不同的数据源，以到达切换数据源的目的。
spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。基本上都是动态地给一个对象添加一些额外的职责。 

**第六种：代理（Proxy）**

为其他对象提供一种代理以控制对这个对象的访问。  从结构上来看和Decorator模式类似，但Proxy是控制，更像是一种对功能的限制，而Decorator是增加职责。 
spring的Proxy模式在aop中有体现，比如JdkDynamicAopProxy和Cglib2AopProxy。 

**第七种：观察者（Observer）**

定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
spring中Observer模式常用的地方是listener的实现。如ApplicationListener。 

**第八种：策略（Strategy）**

定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。 
spring中在实例化对象的时候用到Strategy模式
在SimpleInstantiationStrategy中有如下代码说明了策略模式的使用情况： 
![img](https://images2017.cnblogs.com/blog/106546/201708/106546-20170820090830818-985726848.png)

 


**第九种：模板方法（Template Method）**

定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
Template Method模式一般是需要继承的。这里想要探讨另一种对Template Method的理解。spring中的JdbcTemplate，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。这可能是Template Method不需要继承的另一种实现方式吧。 