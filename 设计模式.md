# 设计模式

软件工程中，针对某些场景、某类问题的某种通用的解决方案。

![img](https://images2017.cnblogs.com/blog/401339/201709/401339-20170928225241215-295252070.png)



## 单例模式

饿汉式在Class文件加载时就创建实例，所以创建实例的过程是安全的。但是饿汉式的创建方式在 Singleton 实例的创建需要依赖配置文件的情况下是无法使用的。

### 懒汉式-双重检验锁

```java
volatile private static MySingleton instance = null;   //使用volatile关键字保证其可见性
private MySingleton() { //构造方法私有化
}
public static MySingleton getInstance() {
    if (instance == null) {
        synchronized (MySingleton.class) {
            if (instance == null) {//二次检查  why??
                instance = new MySingleton();
            }
        }
    }
    return instance;
}
```

### 懒汉式-枚举

枚举类的加载过程是线程安全的，可通过此特性构造线程安全的单例

```java
//构造单例
public class ClassFactory {
    private enum MyEnumSingleton {
        singletonFactory; //该枚举类的实例
        private Person instance; //每个枚举类都有的字段
        MyEnumSingleton() {//枚举类的构造方法在类加载是被实例化
            instance = new Person();
        }
        public Person getInstance() {
            return instance;
        }
    }
    public static Person getInstance() {
        return MyEnumSingleton.singletonFactory.getInstance();
    }
}
//获取单例
Object object = ClassFactory.getInstance()
```

## 策略模式

当实现某一个功能存在多种算法或者策略，如果使用多重条件转移语句实现（即硬编码），不但使条件语句变得很复杂，而且增加、删除或更换算法会违背开闭原则。如果采用策略模式就能很好解决该问题。  

策略模式的主要优点如下。

1. 多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。
2. 策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。
3. 策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。
4. 策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。
5. 策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。

其主要缺点如下。

1. 客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。
2. 策略模式造成很多的策略类。

### 模式的结构

策略模式的主要角色如下：

1. 抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。
2. 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。
3. 环境（Context）类：持有一个策略类的引用，最终给客户端调用。

```java
interface Strategy {//抽象策略接口
    public void strategyMethod();    //策略方法
}
//具体策略类A
class ConcreteStrategyA implements Strategy {
    public void strategyMethod() {
        System.out.println("具体策略A的策略方法被访问！");
    }
}
//具体策略类B
class ConcreteStrategyB implements Strategy {
    public void strategyMethod() {
        System.out.println("具体策略B的策略方法被访问！");
    }
}
//环境类
class Context {
    private Strategy strategy;
    public Strategy getStrategy() {
        return strategy;
    }
    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }
    public void strategyMethod() {
        strategy.strategyMethod();
    }
}
```

### 策略模式的扩展

在一个使用策略模式的系统中，当存在的策略很多时，客户端管理所有策略算法将变得很复杂，如果在环境类中使用策略工厂模式来管理这些策略类将大大减少客户端的工作复杂度，

![ç­ç¥å·¥åæ¨¡å¼çç»æå¾](http://c.biancheng.net/uploads/allimg/181116/3-1Q116104010550.gif)