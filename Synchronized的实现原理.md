## Synchronized的实现原理

### 1. 锁在哪

在Synchronized关键字中，Java中的所有对象都可以作为锁：

 - 对于普通同步方法，锁存在于当前实例对象中。
 - 对于静态同步方法，锁存在于当前类的Class对象中。
 - 对于同步方法块，锁存在于Synchronized括号里配置的对象中。

### 2. 锁的4种状态

HotSpot虚拟机中，Java对象在内存中的布局包括对象头、实例数据和对齐填充。Java对象头中的内容如下：

![img](http://images2015.cnblogs.com/blog/731716/201703/731716-20170302104003563-2094361065.png)

在JDK1.6中，锁一共有4种状态，从低到高依次为：无锁状态、偏向锁、轻量级锁、重量级锁。锁的状态会随着竞情况逐渐升级。锁可以升级但不能降级。

Synchronized关键字用的锁就保存在对象头的MarkWord中。在运行期间，MarkWord中的数据会随着锁标志位的变化而变化。具体为：

![img](https://img-blog.csdn.net/20151217151455512?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)



#### 1. 偏向锁

Hotspot的作者经研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得。

偏向锁的特点是加解锁不需要额外的开销。适用于***没有多线程竞争同步代码块的情况***

如前所示，当锁标志位设置为偏向锁时，Java对象头的MarkWord中会保存当前锁偏向的线程ID。

1. 偏向锁获取过程：	

　　（1）访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，确认为可偏向状态。
　　（2）如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤（5），否则进入步骤（3）。
　　（3）如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行（5）；如果竞争失败，执行（4）。
　　（4）如果CAS获取偏向锁失败，则表示有竞争。此时会在全局安全点（safepoint，此时没有正在执行的字节码）时将获得偏向锁的线程挂起，然后偏向锁会升级为轻量级锁。之后被阻塞在安全点的线程继续往下执行同步代码。
　　（5）执行同步代码。

2. 偏向锁的释放：

　　偏向锁只有遇到存在多线程竞争锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。

#### 2. 轻量级锁（自旋锁）
轻量级锁的特点：参与竞争的线程如果获取不到锁，会短暂自旋（继续占用CPU）而不是阻塞，提高了程序的响应速度，避免线程切换的带来开销。适用于***同步代码块执行时间短的情况。***

1. 轻量级锁的加锁过程

　　（1）在线程进入同步块时，如果锁状态为无锁状态，虚拟机首先将在该线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。
　　（2）拷贝锁对象头中的Mark Word复制到Lock Record空间中。
　　（3）拷贝成功后，虚拟机将CAS的将锁对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向锁对象的mark word。如果更新成功，则执行步骤（4），否则执行步骤（5）。
　　（4）如果更新成功，则表示该线程已经获取了锁，且锁对象Mark Word的锁标志位为轻量级锁定状态。
　　（5）如果更新失败，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经获取了锁。否则说明存在多个线程竞争锁，此时该线程会进行短暂自旋并继续尝试获取锁。如果自旋期间获取锁失败，则轻量级锁会膨胀为重量级锁，（此时锁标志位设置为重量级锁，且Mark Word中存储的就是指向重量级锁（互斥量）的指针），之后该线程进入阻塞状态，后面如果再有争夺锁的线程也要进入阻塞状态。 

2. 轻量级锁的释放

   轻量级解锁时，会以CAS的方法将对象头的Mark Word中的值设置为Displaced Mark Word的值，如果成功，则表示同步过程已完成。如果失败，表示有其他线程尝试过获取该锁（此时对象头的MarkWord中锁标志位已更改为重量级锁），此时该线程就需要在释放锁的同时唤醒其他被阻塞的线程。

#### 3. 重量级锁

