## 查找

### 二分查找 / 折半查找 
说明：数据必须是有序的。    

```java
public int binarySearch(int[] nums, int target) {
	int low = 0;
	int hign = nums.length - 1;
	int q = nums.length;
	while (low <= hign) {
		int m = (low + hign) / 2;
		System.out.println(low + "\t" + hign);
		if (nums[m] == target) {
			if (q > m) {
				q = m;
			}
		}
		if (nums[m] >= target) {
			hign = m - 1;
		} else {
			low = m + 1;
		}
	}
	if (q != nums.length)
		return q;
	else
		return -1;
}
public void buildMaxHeap(int[] A) {
	for (int i = A.length / 2; i > 0; i--) {
		this.maxHeapify(A, i);
	}
}
```

## 排序

### 快速排序
```java	
public void quickSort(int[] nums, int left, int right) {
    if (left > right){
        return;
    }
    int temp = nums[left]; // temp中存的就是基准数
    int i = left;
    int j = right;
    while (i != j) {
        // 顺序很重要，要先从右边开始找
        while (nums[j] >= temp && i < j)
            j--;
        // 再找右边的
        while (nums[i] <= temp && i < j)
            i++;
        // 交换两个数在数组中的位置
        if (i < j) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }
    // 最终将基准数归位
    nums[left] = nums[i];
    nums[i] = temp;	

    quickSort(nums, left, i - 1);// 继续处理左边的，这里是一个递归的过程
    quickSort(nums, i + 1, right);// 继续处理右边的 ，这里是一个递归的过程
}
```
### 堆排序（大顶堆）

```java
//堆排序时间复杂度
//堆排序的时间复杂度是O(N*lgN)。
public void maxHeapify(int[] A, int i, int heapSize) {
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    int max = i;
    if (left < heapSize && A[left] > A[i]) {
        max = left;
    }
    if (right < heapSize && A[right] > A[max]) {
        max = right;
    }
    if (max != i) {
        swap(A, i, max);
        this.maxHeapify(A, max, heapSize);
    }
}
public void swap(int[] A, int i, int j) {
    int temp = A[i];
    A[i] = A[j];
    A[j] = temp;
}
void heapSort(int[] A) {
    //将数组构建成大顶堆
    for (int i = A.length / 2 - 1; i >= 0; i--) {
        maxHeapify(A, i, A.length);
    }
    //大顶堆构建成功后，堆顶元素是数组的最大值
    //这样每次将数组的最大值与最后一个元素交换，然后将剩下的元素再通过构建大顶堆来取出其中的最大值
    for (int i = A.length - 1; i > 0; i--) {
        swap(A, 0, i);
        //每次调整都是从根节点开始i不断减小，保证前一次最大节点不会参与到调整堆
        maxHeapify(A, 0, i);
    }
}
```

### 归并排序

```java
public void merge(int[] nums, int first, int mid, int last, int[] sorted) {
    int i = first, j = mid;
    int k = 0;
    while (i < mid && j < last){
        if (nums[i] < nums[j]) {
            sorted[k++] = nums[i++];
        } else {
            sorted[k++] = nums[j++];
        }
    }
    while (i < mid) {
        sorted[k++] = nums[i++];
    }
    while (j < last) {
        sorted[k++] = nums[j++];
    }
    for (int v = 0; v < k; v++) {
        nums[first + v] = sorted[v];
    }
}
public void mergeSort(int[] nums, int first, int last, int[] sorted) {
    if (first + 1 < last) {
        int mid = (first + last) / 2;

        mergeSort(nums, first, mid, sorted);
        mergeSort(nums, mid, last, sorted);
        merge(nums, first, mid, last, sorted);
    }
}
```

### 冒泡排序

```java
//从小到大排序
public void bubbleSort(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        for (int j = 0; j < nums.length - 1; j++) { 
            if (nums[j] > nums[j + 1]) {//冒泡排序是前后相邻的两个比较
                int temp = nums[j];
                nums[j] = nums[j + 1];
                nums[j + 1] = temp;
            }
        }
    }
}
```

### 选择排序

```java
//从小到大排序
public void selectionSort(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        int min = i;
        for (int j = i + 1; j < nums.length; j++) {
            if (nums[j] < nums[min]) { //选择排序是选出最小值，然后和nums[i]交换
                min = j;
            }
        }
        if (min != i) {
            int temp = nums[i];
            nums[i] = nums[min];
            nums[min] = temp;
        }
    }
}
```



## 二叉树

### 层次遍历
```java
//	方法一：
public void levelOrder(TreeNode root) {
    if (root == null)
        return ;
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.add(root);

    while (queue.size() != 0) {
        TreeNode node = queue.poll();
        System.out.println(node.val);
        if (node.left != null) {
            queue.add(node.left);
        }
        if (node.right != null) {
            queue.add(node.right);
        }
    }
}

//方法二：
public void levelOrder(TreeNode root) {
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.add(root);
    while (queue.size() != 0) {
        TreeNode node = queue.poll();
        if (node != null) {
            System.out.println(node.val);
            queue.offer(node.left);
            queue.offer(node.right);
        }
    }
}
```

### 前序遍历（根左右）

```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<Integer>();

    if (root == null){
        return list;
    }
    Stack<TreeNode> s = new Stack<TreeNode>();
    s.push(root);
    while (s.size() != 0) {
        TreeNode node = s.pop();
        list.add(node.val);
        if (node.right != null) {
            s.push(node.right);
        }
        if (node.left != null) {
            s.push(node.left);
        }
    }
    return list;
}
```

### 中序遍历（左根右）

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<Integer>();
    TreeNode node = root;
    if (root == null)
        return list;
    Stack<TreeNode> s = new Stack<TreeNode>();

    while (s.size() != 0 || node != null) {
        while(node != null){
            s.push(node);
            node = node.left;
        }
        node = s.pop();
        list.add(node.val);
        node = node.right;
    }
    return list;
}
```

### 后序遍历（左右根）
```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<Integer>();
    Stack<TreeNode> stack = new Stack<TreeNode>();
    TreeNode prev = null; // previously traversed node
    TreeNode curr = root;

    if (root == null) {
        return result;
    }

    stack.push(root);
    while (!stack.empty()) {
        curr = stack.peek();
        if (prev == null || prev.left == curr || prev.right == curr) { // traverse down the tree
            if (curr.left != null) {
                stack.push(curr.left);
            } else if (curr.right != null) {
                stack.push(curr.right);
            }
        } else if (curr.left == prev) { // traverse up the tree from the left
            if (curr.right != null) {
                stack.push(curr.right);
            }
        } else { // traverse up the tree from the right
            result.add(curr.val);
            stack.pop();
        }
        prev = curr;
    }

    return result;
}
```