## redis集群分片

分片(partitioning)就是将你的数据拆分到多个 Redis 实例的过程。Redis 引入另一种哈希槽（hash slot）的概念。Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法得出结果，然后对 16384 求余数，这样每个 key 对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同节点。

原来的redis分片实现：

- 客户端分片(Client side partitioning)，客户端直接选择正确的节点来写入和读取指定键。

- 代理协助分片(Proxy assisted partitioning)，客户端发送请求到一个可以理解 Redis 协议的代理上，而不是直接发送请求到 Redis 实例上。代理会根据配置好的分片模式，来保证转发请求到正确的 Redis 实例，并返回响应给客户端。

- 查询路由(Query routing)，发送查询到一个随机实例，这个实例会保证转发查询到正确的节点。 

新版本Redis的解决办法:

Redis3.0版的一大特性就是支持集群（Cluster)功能。Redis集群是自动分片和高可用的首选方式。集群的特点在于拥有和单机实例同样的功能，同时在网络分区后能够提供一定的可访问性以及对主数据库故障恢复的支持。

## redis的主从复制

1. 同一个Master可以同步多个Slaves节点。
2. Slave同样可以接受其它Slaves的连接和同步请求。
3. Master Server是以非阻塞的方式为Slaves提供服务。所以在Master-Slave同步期间，客户端仍然可以提交查询或修改请求。
4. Slave Server同样是以非阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis则返回同步之前的数据。
5. 为了分载Master的读操作压力，Slave服务器可以为客户端提供只读操作的服务，写服务仍然必须由Master来完成。从而实现读写分离

在Slave启动并连接到Master之后，它将主动发送一个SYNC命令。此后Master将启动后台存盘进程，同时收集所有接收到的用于修改数据集的命令，在后台进程执行完毕后，Master将传送整个RDB数据库文件到Slave，以完成一次完全同步。而Slave服务器在接收到数据库文件数据之后将其存盘并加载到内存中。此后，Master继续将所有已经收集到的修改命令，和新的修改命令依次传送给Slaves，Slave将在本次执行这些数据修改命令，从而达到最终的数据同步。若Master和Slave之间的链接出现断连现象，Slave可以自动重连Master，但是在连接成功之后，一次完全同步将被自动执行。 





## redis的持久化*

6.1、Redis提供的持久化机制： 

1). RDB持久化：该机制是指在指定的时间间隔内将内存中的数据集快照写入磁盘。 

2). AOF持久化：该机制将以日志的形式记录服务器所处理的每一个写操作，在Redis服务器启动之初会读取该文件来重新构建数据库，以保证启动后数据库中的数据是完整的。

6.2、RDB机制的优势和劣势：

优势：
1). 采用该方式，整个Redis数据库将只包含一个文件，通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。
2). 性能最大化，对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，再由子进程完成这些持久化的工作，这样可以极避免服务进程执行IO操作。
劣势：

1). 如果你想保证数据的高可用性，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。

2). 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务一定的时间。

6.3、AOF机制的优势和劣势： 

优势
1). 带来更高的数据安全性，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。

2). 由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，在Redis下一次启动之前，可以通过redis-check-aof工具来解决数据一致性的问题。

3). 如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。

4). AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。
劣势
1). 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。
2). 根据同步策略的不同，AOF在运行效率上往往会慢于RDB。





Redis Cluster是一种服务器Sharding技术，3.0版本开始正式提供。Redis Cluster中，Sharding采用**slot(槽)的概念，一共分成16384个槽，这有点儿类似前面讲的pre sharding思路。对于每个进入Redis的键值对，根据key进行散列，分配到这16384个slot中的某一个中。使用的hash算法也比较简单，就是CRC16后16384取模。Redis集群中的每个node(节点)负责分摊这16384个slot中的一部分，也就是说，每个slot都对应一个node负责处理。当动态添加或减少node节点时，需要将16384个槽做个再分配，槽中的键值也要迁移。当然，这一过程，在目前实现中，还处于半自动状态，需要人工介入。**

 

Redis集群，要保证16384个槽对应的node都正常工作，如果某个node发生故障，那它负责的slots也就失效，整个集群将不能工作。为了增加集群的可访问性，官方推荐的方案是将node配置成主从结构，即一个master主节点，挂n个slave从节点。这时，如果主节点失效，Redis Cluster会根据选举算法从slave节点中选择一个上升为主节点，整个集群继续对外提供服务。这非常类似前篇文章提到的Redis Sharding场景下服务器节点通过Sentinel监控架构成主从结构，只是Redis Cluster本身提供了故障转移容错的能力。

 

Redis Cluster的新节点识别能力、故障判断及故障转移能力是通过集群中的每个node都在和其它nodes进行通信，这被称为集群总线(cluster bus)。它们使用特殊的端口号，即对外服务端口号加10000。例如如果某个node的端口号是6379，那么它与其它nodes通信的端口号是16379。nodes之间的通信采用特殊的二进制协议。

 

对客户端来说，整个cluster被看做是一个整体，客户端可以连接任意一个node进行操作，就像操作单一Redis实例一样，当客户端操作的key没有分配到该node上时，就像操作单一Redis实例一样，当客户端操作的key没有分配到该node上时，Redis会返回转向指令，指向正确的node，这有点儿像浏览器页面的302 redirect跳转。

Redis Cluster是Redis 3.0以后才正式推出，时间较晚，目前能证明在大规模生产环境下成功的案例还不是很多，需要时间检验。





https://segmentfault.com/a/1190000016981700



https://uule.iteye.com/blog/2431878



https://www.cnblogs.com/gzy-blog/p/6058849.html



https://www.cnblogs.com/crazylqy/p/7455633.html