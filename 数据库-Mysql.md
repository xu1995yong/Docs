# MYSQL数据库

## Mysql数据库引擎比较

1. InnoDB存储引擎：InnoDB是默认的MySQL引擎，适用于OLTP的数据库应用。InnoDB存储引擎支持事务，采用行锁设计、支持外键约束、并提供非锁定读。InnoDB引擎使用多版本并发控制来获得高并发性，并且实现了SQL标准的4种隔离级别，默认为REPEATABLE级别。同时使用next-key locking的策略来避免幻读。
2. MyISAM存储引擎：主要面向OLAP的数据库应用。它提供高速存储和检索，以及全文搜索的能力。不支持事务，采用表锁设计，不支持外键。

## 业务层面的锁

### 乐观锁
**原理**：乐观锁认为数据一般情况下不会造成冲突，所以不会对数据提前加锁，而是在提交数据更新的时候，才对冲突进行检测。
**实现机制**：实现乐观锁有两种方式：

1. 使用版本号或者时间戳：数据版本是为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果标识值相等则予以更新，否则不更新数据。
2. 使用条件限制实现：适用于库存模型。

### 悲观锁
即在操作数据前，都要先获取该数据的锁。
**实现机制**：采用可重复读的事务隔离级别。

### 两者间的比较
两种锁各有优缺点。乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。

## INNODB中的锁
### 1.行级锁及其3种实现
InnoDB实现了两种标准的行级锁：

- 共享锁：允许事务读一行数据，加锁方式：SELECT ... LOCK IN SHARE MODE
- 排他锁：允许事务删除或更新一行数据。通常对于UPDATE或者DELETE操作，或者SELECT … FOR UPDATE操作，都会对记录加排他锁。

如果一个事务持有了一个共享锁，其他事务仍然可以获取这行记录的共享锁，但不能获取到这行记录的排它锁。当一个事务获取到了某一行的排它锁，则其他事务将无法再获取这行记录的共享锁和排它锁。

**InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则InnoDB将使用表锁。**

**行锁的3种实现**

InnoDB存储引擎有3种行锁的算法：

- Record Lock：单个行记录上的锁。
- Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。
- Next-Key Lock：等价于Record Lock + Gap Lock，锁定一个范围并锁定记录本身。Next-Key Lock解决了幻读问题。

### 2. 意向锁
InnoDB支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁共存。为了支持在不同粒度上进行加锁操作，InnoDB提供了两种意向锁：

- 意向排它锁（简称 IX 锁）表明一个事务意图在某个表中设置某些行的 x 锁
- 意向共享锁（简称 IS 锁）表明一个事务意图在某个表中设置某些行的 s 锁

意向锁的原则如下：

- 一个事务必须先持有该表上的 IS 或者更强的锁才能持有该表中某行的 S 锁
- 一个事务必须先持有该表上的 IX 锁才能持有该表中某行的 X 锁

这样根据锁的兼容矩阵，就避免了行级锁与表级锁间的冲突。

### 3. 表级锁

表级锁是 MySQL 中锁定粒度最大的一种锁，表示对当前操作的整张表加锁。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。


## INNODB中的MVCC

MVCC（多版本并发控制）是一种提高数据库并发性的技术。它提供了一致性非锁定的读，来避免事务间读写操作的阻塞，提高数据库系统的并发性能。

一致性非锁定读：即如果读取的行正在执行delete或者update操作，则读取操作不等待锁的释放，而是读该行的一个快照数据（即事务的undo段中记录的该行数据的之前版本）。

MVCC只适用于READ COMMITTED和REPEATABLE READ事务隔离级别中，且在不同的事务隔离级别下对快照数据的定义不同：

- 在READ COMMITTED事务隔离级别下，快照数据是指被锁定行的最新版本数据。
- 在REPEATABLE READ事务隔离级别下，快照数据是指事务开始时的数据版本。




## 事务

### 事务的ACID特性

1. A(Atomicity)原子性：事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。

2. C(Consistency)一致性：
3. I(Isolation)隔离性：
4. D(Durability)持久性：

### 事务并发带来的问题

1. 脏读：当前事务可以读到另一事务修改但尚未提交的数据。脏读违反了事务的隔离性。

   ![img](https://upload-images.jianshu.io/upload_images/5879294-6424e361ec6ae52e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

2. 不可重复读：在事务执行过程中，由于其他事务修改了数据，导致当前事务前后两次SELECT返回的结果集中记录的值不同。不可重复读违反了事务的一致性。

   ![img](https://upload-images.jianshu.io/upload_images/5879294-a5aa7d5671f3b770.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

3. 幻读：在事务执行过程中，由于其他事务增加或删除了数据，导致当前事务前后两次SELECT返回的结果集中记录的数量不同。

   ![img](https://upload-images.jianshu.io/upload_images/5879294-2d4b770f4afd4871.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)
   
   **在Repeatable Read隔离级别下，InnoDB引擎采用Next-Key Lock来解决幻读现象**
举例说明如何解决：
>   例如：CREATE TABLE T (a int primary key)，表T中由1，2，5这三个值组成。
>   若这时事务T1执行select * from t where a > 2 for update;该操作应该返回5这个结果，但如果此时另一个事务T2插入了4这个值，那事务T1再次执行上述的SQL会得到4和5，这样就产生了幻影现象。
>   当InnoDB引擎采用Next-Key Lock算法时，对于语句select * from t where a > 2 for update，其锁住的不只是5这单个值，而是对（2，+∞）这个范围加了X锁。这样对于这个范围的插入都是不被允许的，从而避免了幻影现象。

4. 丢失修改：一个事务的更新操作会被另一个事务的更新操作覆盖。在当前数据库的任何隔离级别下，都不会导致数据库理论意义上的丢失修改，因为对数据的修改操作都会加X锁。但是在实际应用中还有另一个逻辑意义的丢失修改问题：
   - 事务A查询一行数据，放入本地内存，并显示给一个终端用户UserA。

   - 事务B也查询该行数据，并将取得的数据显示给终端用户UserB。

   - UserA修改这行记录，更新数据库并提交。

   - UserB修改这行记录，更新数据库并提交。

     要避免丢失更新的发生，有两种方式：

     1. 悲观锁方式：为每个SELECT操作都加上排他锁（FOR UPDATE）。这样事务B就必须等待事务A完成后才能继续。
     2. 乐观锁方式：
### 事务的隔离级别及其实现原理

为了解决事务并发带来的问题，数据库设计了四种隔离级别：

1. 读未提交(Read Uncommitted)：会读取到其他事务中未提交的数据，即脏读。

   - 实现原理：事务对读取操作不加锁；事务对更新操作加共享锁，事务结束才释放。
2. 读已提交(Read Committed)：只能读取到其他事务已经提交的数据。解决了脏读问题，存在不可重复读的问题。

   - 实现原理：事务对读取操作采用MVCC；事务对更新操作加独占锁，事务结束才释放。
3. 可重复读(Repeated Read)：在同一个事务内的所有查询操作都与事务开始的时刻一致。可重复读是InnoDB默认级别。解决了不可重复读，但还存在幻象读。InnoDB中采用next-key lock解决了幻读。

   - 实现原理：事务对读取操作采用MVCC；事务对更新操作加独占锁，事务结束才释放。
4. 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。
   - 实现原理：

## 索引

### B树

B树是一种多叉平衡树。它是为磁盘设计的一种平衡查找树。一棵m阶的B树需满足一下条件：

1. 树中每个结点最多含有m个子树（m>=2）；
2. 除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个子树（向上取整：比自己大的最小整数）；
3. 若根结点不是叶子结点，则至少有2个子树
4. 所有叶子节点均在同一层、


![img](https://pic2.zhimg.com/80/v2-2c2264cc1c6c603dfeca4f84a2575901_hd.jpg)

### B+树







数据库中的B+索引可以分为**聚簇索引**和**辅助索引**。

InnoDB存储引擎表是索引组织表，表中数据按照主键顺序存放。聚簇索引就是按照每张表的主键构造一棵B+树，同时叶子节点中存放表的行记录数据。

### 聚簇索引





## 数据库的分库分表