# MYSQL数据库



## Mysql数据库引擎比较

1. InnoDB存储引擎：InnoDB是默认的MySQL引擎，适用于OLTP的数据库应用。InnoDB存储引擎支持事务，采用行锁设计、支持外键约束、并提供非锁定读。InnoDB引擎使用多版本并发控制来获得高并发性，并且实现了SQL标准的4种隔离级别，默认为REPEATABLE级别。同时使用next-key locking的策略来避免幻读。
2. MyISAM存储引擎：主要面向OLAP的数据库应用。不支持事务，采用表锁设计，不支持外键。支持全文索引。

## 乐观锁与悲观锁

### 1.乐观锁
**原理**：乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果有更新的话，正在提交的事务会进行回滚。
**实现机制**：记录数据版本。实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。
数据版本是为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果标识值相等则予以更新，否则不更新数据。



乐观锁的优势？？？

乐观锁用在哪？？？

乐观锁的作用？？



### 2.悲观锁
在操作数据前，都要先获取该数据的锁。
实现机制：通过使用数据库自身提供的锁机制

### 比较
两种锁各有优缺点。乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。

## INNODB存储引擎中的锁
### 1.行级锁
InnoDB实现了两种标准的行级锁：
  -	共享锁：允许事务读一行数据。
  -	排他锁：允许事务删除或更新一行数据。

如果一个事务持有了一个共享锁，其他事务仍然可以获取这行记录的共享锁，但不能获取到这行记录的排它锁。当一个事务获取到了某一行的排它锁，则其他事务将无法再获取这行记录的共享锁和排它锁。

InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。

### 2.意向锁：表级锁
InnoDB存储引擎支持多种锁粒度，这种锁允许在行级锁和表级锁同时存在。
  -	意向共享锁(IS Lock): 事务想要获得一个表中某几行的共享锁。
  -	意向排它锁(IX Lock): 事务想要获得一个表中某几行的排它锁。

意向锁可以防止锁冲突。
事务在获取共享锁之前必须先获取意向共享锁，同理获取排他锁之前必须先获取意向排它锁。
InnoDB存储引擎支持的是行级别的锁，所以意向锁其实不会阻塞除全表查询以外的任何请求。

### 3.一致性非锁定读
一致性非锁定读：指InnoDB存储引擎通过多行版本控制的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行delete或者update操作的时候，这时候的读取操作不会等待行锁的释放，而是会去读该行的一个快照数据。
快照数据是指该行的之前版本的数据，该实现是通过事务的undo段来完成的。

**非锁定读在不同的事务隔离级别下对快照数据的定义不同**
  -	在REPEATABLE READ事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的数据版本。
  -	在READ COMMITTED事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新版本数据。

### 4.一致性锁定读
为了保证数据逻辑的一致性，有时数据库需要支持一致性的锁定读。
InnoDB对SELECT语句提供了两种类型的锁定读：
  -	SELECT ... LOCK IN SHARE MODE：对读取的行加S锁。
  -	SELECT ... FOR UPDATE：对读取的行加X锁。

### 行锁的3种算法
InnoDB存储引擎有3种行锁的算法：
  -	Record Lock：单个行记录上的锁。
  -	Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。
  -	Next-Key Lock：Record Lock + Gap Lock，锁定一个范围，并且锁定记录本身。

**在Repeatable Read隔离级别下，InnoDB引擎采用Next-Key Lock来解决幻读现象**
幻影现象：指在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次执行的SQL语句可能返回第一次执行时不存在的行。
举例说明如何解决：
>   例如：CREATE TABLE T (a int primary key)，表T中由1，2，5这三个值组成。
>   若这时事务T1执行select * from t where a > 2 for update;该操作应该返回5这个结果，但如果此时另一个事务T2插入了4这个值，那事务T1再次执行上述的SQL会得到4和5，这样就产生了幻影现象。
>   当InnoDB引擎采用Next-Key Lock算法时，对于语句select * from t where a > 2 for update，其锁住的不只是5这单个值，而是对（2，+∞）这个范围加了X锁。这样对于这个范围的插入都是不被允许的，从而避免了幻影现象。



## 加锁带来的问题

1. 脏读：当前事务可以读到另一事务尚未提交的数据。
   脏读违反了事务的隔离性。
   脏读需要的事务隔离级别：READ UNCOMMITTED

2. 不可重复读：在事务执行过程中，由于其他事务提交数据，导致当前事务前后两次SELECT会读到不同的结果。
   一般来说，不可重复读的问题是可以接受的，因为其读到的是已经提交的数据。本身并不会带来很大的问题。     
   不可重复读违反了事务的一致性。
   不可重复读需要的事务的隔离级别：READ COMMITTED
   InnoDB引擎通过使用Next-Key Look算法避免了不可重复读的问题。

3. 丢失修改：一个事物的更新操作会被另一个事务的更新操作覆盖，导致数据的不一致。
   在当前数据库的任何隔离级别下，都不会导致数据库理论意义上的丢失修改，因为对数据的修改操作都会加X锁。

   但是在实际应用中还有另一个逻辑意义的丢失修改问题。简单地来说，出现下面的情况时，就会发生丢失修改：
- 第一步：事务A查询一行数据，放入本地内存，并显示给一个终端用户UserA。
- 第二步：事务B也查询该行数据，并将取得的数据显示给终端用户UserB。
- 第三步：UserA修改这行记录，更新数据库并提交。
- 第四步：UserB修改这行记录，更新数据库并提交。
   要避免丢失更新的发生，其实需要让这种情况下的事务变成串行操作。即在上述四步操作时的第（1）步对用户读取的记录加上一个排他锁（FOR UPDATE），同样，发生第（2）步情况下的操作时，用户也需要加上一个排他锁（FOR UPDATE）。这样一来，第（2）步就必须等待第（1）、（3）步完成，最后完成第（4）步。



## 索引

数据库中的B+索引可以分为聚簇索引和辅助索引。

InnoDB存储引擎表是索引组织表，表中数据按照主键顺序存放。聚簇索引就是按照每张表的主键构造一棵B+树，同时叶子节点中存放表的行记录数据。



## 数据库的分库分表

