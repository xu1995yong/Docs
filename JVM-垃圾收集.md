## JAVA中的引用

- 强引用：指在程序代码中普遍存在的引用。只要强引用存在，垃圾收集器就不会回收被引用的对象。
- 软引用：指一些有用但非必须的对象。对用软引用关联的对象，在系统要发生内存溢出异常之前，将会把这些对象列进回收范围中进行第二次回收。如果这次回收后还没有足够的内存，将抛出内存溢出异常。
- 弱引用：也指非必要的对象，被弱引用关联的对象只能生存到下一次垃圾收集之前。
- 虚引用：一个对象是否存在虚引用完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象的实例。

## 对象的内存分配策略

1. 大多数情况下，对象在新生代的Eden区中分配。若Eden区中没有足够空间，虚拟机将发起一次MinorGC。
2. 大对象直接进入老年代
3. 长期存活的对象将进入老年代
   1. JVM为每个对象定义了年龄计数器。对象在Eden出生时年龄为零。如果经过第一次MinorGC后存活并能被Survivor容纳，该对象将被移动到Survivor中，且对象年龄加一。当对象的年龄增加到一定程度，就会被移入老年代。
   2. 如果在Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半，则大于或等于该年龄的对象直接进入老年代。
4. Survivor无法容纳的对象直接进入老年代（空间分配担保策略）：因为新生代使用复制收集算法，需要使用其中一个Survivor来作为轮换备份。而当出现大量对象在MinorGC后仍然存活的情况时，就需要老年代进行空间分配担保，使Survivor无法容纳的对象直接进入老年代。

# 对象是否需要回收

## 引用计数算法

思路：为对象添加一个引用计数器，每当该对象被引用时计数器加一，当引用失效时计数器减一。计数器为零则证明对象没有被引用，是可回收的。缺点：不能解决对象之间循环引用的问题。

## 可达性分析算法

思路：以一系列称为“GC Roots”的对象为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，**当一个对象到GC Roots没有任何引用链相连，则该对象是可回收的**。

可作为GC Roots的对象包括以下几种：

- 虚拟机栈中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈（Native方法）中引用的对象。

### 可达性分析在HotSpot中的实现





## 方法区（永久代）中对象是否需要回收

永久代中的垃圾回收主要包括**废弃常量的回收**和**类型的卸载**。

### 如何判断废弃常量：同样采用可达性分析

### 如何判断类型无用（要满足3个条件）

- 该类所有的实例都已经被回收，即JAVA堆中不存在该类的任何实例。

- 加载该类的ClassLoader已经被回收。

- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。


# 对象该如何回收

## 垃圾收集算法

为了方便对内存的管理，JVM将堆内存划分为新生代和老年代。其中新生代一般用来存放刚创建的对象，老年代用来存放长期存在的对象。

### 复制算法（用来回收新生代）

将可用内存分为一块较大的Eden空间和两块较小的Survivor空间（8：1），每次只使用Eden和其中一块Survivor空间。当回收时，将Eden和这块Survivor中还存活着的对象一次性的复制到另外一块Survivor上，最后清理掉Eden和刚才用过的Survivor空间。

**分配担保机制**：即如果另外一块Survivor没有足够空间存放存活对象时，这些对象将通过分配担保机制直接进入老年代。

### 标记-清除（用来回收老年代）

该算法分为标记和清除两个阶段。

- 标记阶段：标记出所有需要回收的对象。
- 清除阶段：统一回收所有被标记的对象。

不足：算法会产生大量的不连续内存碎片，容易提前触发另一次的垃圾回收。

### 标记-整理（用来回收老年代）

该算法分为标记和整理两个阶段。

- 标记阶段：标记出所有需要回收的对象。
- 整理阶段：让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

## 垃圾收集器

![âåå¾æ¶éå¨âçå¾çæç´¢ç"æ](https://upload-images.jianshu.io/upload_images/4685968-3a367913acebef67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/707/format/webp)

### Serial收集器(新生代收集器)

采用复制算法。

特点：
1. 采用单线程完成垃圾收集工作。

2. 在进行垃圾收集时，必须暂停其他所有的工作线程，直到收集结束。

### Serial Old收集器（老年代收集器）

Serial Old收集器是采用标记-整理算法的单线程收集器。

### ParNew收集器（新生代收集器）

采用多线程进行垃圾收集，是Serial收集器的多线程版本。
ParNew是运行在Server模式下的虚拟机首选的新生代收集器，因为除了Serial收集器外，只有ParNew能与CMS收集器配合工作。

### Parallel Scavenge收集器（新生代收集器）

Parallel Scavenge收集器采用复制算法。Parallel Scavenge收集器的目标是达到一个可控制的吞吐量。高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。
吞吐量 = 运行用户代码时间 / （运行用户代码时间+垃圾收集时间）。

### Parallel  Old收集器（老年代收集器）

Parallel  Old收集器是采用标记-整理算法的多线程收集器。

### CMS收集器（老年代收集器）

CMS收集器以获取最短回收停顿时间为目的，适用于B/S系统的服务端应用。

CMS收集器采用标记-清除算法。过程包含4个步骤：
- 初始标记：标记GC Roots能直接关联到的对象，速度很快，需要StopTheWorld。
- 并发标记：进行GC Roots Tracing。可以和用户线程一起工作。
- 重新标记：为了修正并发标记期间因用户程序继续运作而导致的标记变动。需要StopTheWorld。
- 并发清除：可以和用户线程一起工作。

缺点：

- CMS收集器对CPU资源敏感。在并发阶段会占用CPU资源而导致应用程序变慢，总吞吐量降低。
- CMS收集器无法处理浮动垃圾。浮动垃圾是指并发清理阶段用户线程产生的垃圾。这部分垃圾产生在标记过程之后，所以当次收集过程无法处理。
- CMS收集器可能导致ConcurrentModeFailure。由于CMS收集器与用户线程并发执行，就需要预留足够的内存空间给用户线程使用。如果CMS运行期间预留内存无法满足需求，就会出现ConcurrentModeFailure失败。此时虚拟机临时启用SerialOld收集器来进行老年代收集。
- CMS收集器采用标记-清除算法，会产生大量内存碎片。此时CMS会进行内存碎片合并。

### G1（Garbage First）收集器（全堆收集器）

G1收集器将整个堆划分为多个大小相等的区域（Region），新生代和老年代都是部分不连续的Region块的集合。

在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。

工作流程：

- 初始标记：用于标记GC Roots能直接关联到的对象，并且修改TAMS的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象。该阶段需要StopTheWorld。
- 并发标记：从GC Roots开始对堆中对象进行可达性分析，找出存活的对象。该阶段耗时时间长，但可以和用户程序并发执行。
- 最终标记：用于修正并发标记期间因用户程序运作而导致标记产生变动的那一部分标记记录，并将变化记录在线程Remenbered Set Logs里面，最后将Remembered Set Logs的数据合并到Remembered Set中。该阶段需要停顿线程，但可以并发执行。
- 筛选回收：对各个Region的回收价值和成本进行排序，并优先回收收益更高（包含可回收的对象更多）的Region。

G1收集器提供了两种GC模式，Young GC和Mixed GC。Young GC用于回收新生代，Mixed GC用于回收新生代和部分收集收益高的若干老年代Region。G1收集器不提供FullGC。

G1收集器同CMS相比的优势：

- G1是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片。
- G1的Stop The World(STW)更可控，G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间。

## MinorGC与FullGC

- MinorGC是指发生在新生代的垃圾收集，当 JVM 无法为一个新的对象分配空间时会触发 Minor GC。

- FullGC是指发生在整个堆上的垃圾收集，包括新生代和老年代。当老年代中最大可用的连续空间小于新生代所有对象总空间时会触发FullGC。









