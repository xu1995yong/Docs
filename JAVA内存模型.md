# 	JAVA内存模型

### 1. CPU中的缓存

在多核CPU中，L1和L2缓存是各核心独有，L3缓存所有核心共享。

### 2. JMM的定义

为了屏蔽各种硬件和操作系统的内存差异，JVM定义了JMM（JAVA内存模型）。

1. 主内存：主内存是所有线程共享。负责存储所有可被多线程共享的变量，即实例字段、静态字段、构成数组对象的元素。主内存可类比硬件内存。

2. 工作内存：工作内存是各线程独有，保存被该线程使用到的变量的主内存副本拷贝。工作内存可类比CPU的L1、L2缓存。

JMM规定，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程间也无法直接访问其工作内存中的变量值，变量值的传递均需要通过主内存完成。

### 3. 并发编程中的三个问题

1. 原子性：即一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 

2. 可见性：即当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改后的值。

3. 有序性：为了提高执行效率，Java允许对指令重排序，有序性指在指令重排序之后，程序执行的结果与按代码先后顺序的执行结果相同。



### 4. JMM对原子性、可见性、有序性的保证

1. 原子性：JMM只保证基本读取和赋值（必须是将数字赋值给某个变量）是原子操作。

   ​		JMM提供synchronized和Lock来实现更大范围的原子性。

2. 可见性：JMM提供volatile关键字来保证。另外synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。

3. 有序性：JMM只保证单线程下代码的有序性，并不保证多线程下代码的有序性。

   ​	此外，JMM具备一些先天的“有序性”，即happens-before原则（先行发生原则）：

   - 程序次序规则：单线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。

   - 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作。

   - volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。

     （即对volatile变量的写与随后对这个volatile变量的读之间不能进行指令重排序。这是JMM保证的，而不是volatile关键字保证的。）

   - 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则A先于C发生。

如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。如果需要更大规模的有序性，JMM提供volatile关键字，或者synchronized和Lock来实现。





