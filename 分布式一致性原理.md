## 分布式事务

### 1. CAP理论
一个分布式系统不可能同时满足一致性、可用性和分区容错性这三个基本需求，最多只能同时满足其中的两项。
- 一致性：指数据在多个副本之间是否能够保持一致的特性。
- 可用性：指系统提供的服务必须一直处于可用的状态，对于用户的每个请求总是能够在有限的时间内返回结果。
- 分区容错性：指分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境故障。（分区容错性必须要保证）

### 2. BASE理论

## 一致性协议（为了解决分布式一致性问题）

在分布式系统中，当一个事务操作需要跨越多个节点的时候，就需要引入“协调者”组件来统一调度所有分布式节点的执行逻辑，而被调度的分布式节点则被称为“参与者”。

### 1. 二阶段提交协议（2PC）
将事务的提交过程分为两个阶段。
  -  阶段一：投票阶段
	  1. 协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，并等待参与者的响应。
	  2. 各参与者执行事务操作，并将UNDO和REDO信息记入事务日志。
	  3. 如果参与者成功执行了事务操作，就反馈给协调者YES响应。否则就反馈NO响应。
  - 阶段二：执行阶段：在该阶段，协调者会根据各参与者的反馈来决定是否可以进行事务提交。一般包含两种情况：
	  - 提交事务：当协调者从所有参与者获得的反馈都是YES响应。
		  1. 协调者向所有参与者发送Commit请求。
		  2. 参与者收到Commit请求后，正式进行事务提交操作。并在完成后向协调者发送ACK消息。
		  3. 协调者收到所有参与者的ACK响应后，完成事务提交。
	  - 中断事务：当有参与者向协调者反馈了NO响应；或超时之前，协调者没有收到所有参与者的反馈。
		  1. 协调者向所有参与者发送ROLLBACK请求。
		  2. 参与者收到ROLLBACK请求后，根据UNDO信息执行事务回滚操作。并在完成后向协调者发送ACK消息。
		  3. 协调者收到所有参与者发送的ACK消息后，完成事务中断.


2PC的缺点：
- 同步阻塞：在2PC的执行过程中，各个参与者在等待其他参与者响应的时侯，无法进行其他任何操作。
- 单点问题：协调者的单点问题。尤其是当协调者在阶段二中出现问题。
- 数据不一致：当协调者向参与者发送Commit请求时出现网络异常。
- 没有容错机制：

### 2. 三阶段提交（3PC）
  -	阶段一：CanCommit阶段
	  1. 协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，并等待参与者的响应。
	  2. 参与者如果其自身认为可以顺利执行事务，则反馈YES响应。否则反馈NO响应。
  - 阶段二：PreCommit阶段：在该阶段，协调者会根据各参与者的反馈来决定是否可以进行事务PreCommit。一般包含两种情况：
	  - 执行事务预提交：当协调者从所有参与者获得的反馈都是YES响应。
		  1. 协调者向所有参与者发送preCommit请求，并进入prepared阶段。
		  2. 各参与者执行事务操作，并将UNDO和REDO信息记入事务日志。
		  3. 如果参与者成功执行了事务操作，就反馈给协调者ACK响应。 
	  - 中断事务：当有参与者向协调者反馈了NO响应；或超时之前，协调者没有收到所有参与者的反馈。
		  1. 协调者向所有参与者发送abort请求。
		  2. 参与者收到abort请求，或在等待过程中出现超时，参与者都会中断事务。
  - 阶段三：DoCommit阶段：该阶段将进行真正的事务提交，存在两种情况。
	   - 执行提交 
	   	 1. 协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。
	   	 2. 参与者接收到doCommit请求之后，执行正式的事务提交。事务提交完之后，向协调者发送Ack响应。
	   	 3. 协调者接收到所有参与者的ack响应之后，完成事务。
	   - 中断事务：协调者没有接收到参与者发送的ACK响应，那么就会执行中断事务。
		   1. 协调者向所有参与者发送abort请求。
		   2. 参与者接收到abort请求之后，利用undo信息来执行事务的回滚操作。并在完成事务回滚之后，向协调者发送ACK消息。
		   3. 协调者接收到参与者反馈的ACK消息之后，中断事务。
		  
2PC与3PC的区别：
相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。
3PC的缺点：
3PC也存在数据一致性问题，因为由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。

3PC为什么比2PC好？
直接分析协调者和参与者都挂的情况。

第二阶段协调者和参与者挂了，挂了的这个参与者在挂之前已经执行了操作。但是由于他挂了，没有人知道他执行了什么操作。

这种情况下，当新的协调者被选出来之后，他同样是询问所有的参与者的情况来觉得是commit还是roolback。这看上去和二阶段提交一样啊？他是怎么解决一致性问题的呢？

看上去和二阶段提交的那种数据不一致的情况的现象是一样的，但仔细分析所有参与者的状态的话就会发现其实并不一样。我们假设挂掉的那台参与者执行的操作是commit。那么其他没挂的操作者的状态应该是什么？他们的状态要么是prepare-commit要么是commit。因为3PC的第三阶段一旦有机器执行了commit，那必然第一阶段大家都是同意commit。所以，这时，新选举出来的协调者一旦发现未挂掉的参与者中有人处于commit状态或者是prepare-commit的话，那就执行commit操作。否则就执行rollback操作。这样挂掉的参与者恢复之后就能和其他机器保持数据一致性了。（为了简单的让大家理解，笔者这里简化了新选举出来的协调者执行操作的具体细节，真实情况比我描述的要复杂）

简单概括一下就是，如果挂掉的那台机器已经执行了commit，那么协调者可以从所有未挂掉的参与者的状态中分析出来，并执行commit。如果挂掉的那个参与者执行了rollback，那么协调者和其他的参与者执行的肯定也是rollback操作。

所以，再多引入一个阶段之后，3PC解决了2PC中存在的那种由于协调者和参与者同时挂掉有可能导致的数据一致性问题。
# Paxos算法