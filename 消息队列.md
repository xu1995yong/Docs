## 消息队列介绍
消息队列中间件是分布式系统中重要的组件，主要解决**应用解耦，异步消息，流量削锋**等问题，实现高性能，高可用，可伸缩和最终一致性架构。

## 消息队列的对比

1. RabbitMQ：采用Erlang开发，**实现了AMQP协议。具有较高的数据一致性、稳定性和可靠性。但性能和吞吐量较差。**
2. kafka：采用Java开发。**追求高吞吐量，只能以Pull的形式消费消息。**适合数据收集业务。
3. RocketMQ：采用Java开发。**具有高吞吐量、高可用、高可靠的特点。支持消息持久化，支持事务消息，支持多种消费模式（集群消费、广播消费）。**

![æ¶æ¯ä¸­é´ä»¶](https://user-gold-cdn.xitu.io/2018/6/28/164457bef2701e85?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 消息通讯的两种模式

1. 点对点：
2. 发布订阅：
3. 广播







## RocketMQ



1. 、能够保证严格的消息顺序
2. 2、提供丰富的消息拉取模式
3. 3、高效的订阅者水平扩展能力
4. 4、实时的消息订阅机制
5. 5、亿级消息堆积能力



### 核心概念

1.	Producer：生产者将消息发送给brokers。RocketMQ提供多种发送范例：同步，异步和单向。
2.	Producer Group：具有相同角色的生产者的组合。如果原始生产者在事务之后崩溃，则brokers可以联系同一Producer Group的不同生产者实例以提交或回滚事务。
3.	Consumer：消费者从brokers获取消息并将其提供给应用程序。从用户应用的角度来看，提供了两种类型的消费者：
   -	PullConsumer ：读取操作中的大部分功能由使用者自主控制
   -	PushConsumer：由系统控制读取操作，收到消息后自动调用处理方法来处理消息，自动保存offset，而且新加入PushConsumer会自动做负载均衡。
4.	Consumer Group：是具有相同角色的消费者的组合。Consumer Group使消息消费方面实现负载平衡和容错目标非常容易。 **Consumer Group的使用者实例必须具有完全相同的主题订阅。**
5.	Topic
Topic是Producer传递消息和Consumer提取消息的类别。Topic与Producer和Consumer的关系非常松散。
	-	一个Topic可能有零个，一个或多个Producer向它发送消息；相反，Producer可以发送不同Topic的消息。
	-	从Consumer的角度来看，Topic可以由零个，一个或多个Consumer群体订阅。类似地，Consumer Group可以订阅一个或多个Topic，只要该组的实例保持其订阅一致即可。
6.	Message：要传递的信息。Message必须有一个Topic，可以将其解释为要发送给的邮件地址。
7.	Message Queue
8.	Tag：Tag也即子主题，为用户提供了额外的灵活性。对于Tag，来自同一业务模块的具有不同目的的消息可以具有相同的主题和不同的标记。标签有助于保持代码的清晰和连贯，而标签也可以方便RocketMQ提供的查询系统。
9.	Broker
Broker是RocketMQ系统的主要组成部分。它接收从生产者发送的消息，存储它们并准备处理来自消费者的拉取请求。它还存储与消息相关的元数据，包括消费者组，消耗进度偏移和主题/队列信息。
10.	Name Server
11.	Message Model
	-	Clustering：同一个ConsumerGroup里的每个Consumer只消费所订阅消息的一部分内容，同一个ConsumerGroup里所有的Consumer消费的内容合起来才是所订阅Topic内容的整体，从而达到负载均衡的目的。
	-	Broadcasting：同一个ConsumerGroup里的每个Consumer都能消费到所订阅Topic的全部消息，也就是一个消息会被多次分发。
12.	Message Order
当使用DefaultMQPushConsumer时，可能决定按顺序或并发使用消息。
	- Orderly：按顺序使用消息意味着消息的使用顺序与生产者为每个消息队列发送的顺序相同。如果您正在处理全局顺序是必需的方案，请确保您使用的主题只有一个消息队列。警告：如果指定了有序消耗，则消息消耗的最大并发数是消费者组订阅的消息队列数。 
	- Concurrently：**此模式不再保证消息顺序. **

### PushConsumer的原理
**PushConsumer中通过“长轮询”方式达到Push效果，长轮询方式既有Pull的优点，又有Push方式的实时性。**
为什么使用长轮询方式：    

  1. 单纯的Push方式的弊端：
	- 加大Server端的工作量，进而影响Server的性能。
	- Client端的处理能力各不相同，Client的状态不受Server控制，如果Client不能及时处理Server推送的消息，就会造成各种问题。	
  2. 单纯的Pull方式的弊端：
	  - 循环拉取消息的间隔不好设定，间隔太短就容易处在“忙等”状态，浪费资源；时间间隔太长，又无法及时处理消息。
	  
### 长轮询方式源码解读
1. Client端
2. Broker端

 



### RocketMQ中的消息有序消费
1. 全局消息有序：指同一个topic下所有的消息都有序。若要在RocketMQ中保证全局消息有序，需要：
   - 发送端：同步发送，异步发送在发送失败的情况下，无法保证消息顺序。
   - 存储端：消息不能分区。即1个topic只能有1个Message Queue。
   - 接收端：不能并行消费，即不能多线程或者多客户端消费同1个队列。

   很明显全局消息有序无法发挥RocketMQ的并发能力。


2. 局部消息有序：即同一个业务id的消息间是有序的。

  - 发送端：只能同步发送（异步发送在发送失败时无法保证消息顺序），并且把同一个业务id（orderId）的消息发送到同一个Message Queue中。这样每个Message Queue中的消息就是有序的。

  - 消费端：使用MessageListenerOrderly类保证同一个Message Queue读取的消息不被并发处理。在MessageListenerOrderly的实现中，为每个Consumer Queue加个锁，消费消息前，都需要先获得这个消息对应的Consumer Queue上的锁。这样保证了同一时间，同一个Consumer Queue的消息只被一个线程消费，而不同Consumer Queue上的消息可以并发处理。

    

### RocketMQ中的消息重复消费与幂等性

RocketMQ中存在消息的重复消费问题，为了解决该问题，需要做到业务逻辑的幂等性。方法有：

1. 根据业务的操作和内容生成全局唯一ID，每次执行操作前先根据全局唯一ID是否存在，来判断操作是否已经执行。如果不存在则把全局ID存储到存储系统中再执行操作，如果存在则表示操作已经执行。
2. 根据数据字段中的唯一索引或唯一组合索引保证业务逻辑的幂等性。