## JAVA内存模型

### JMM的定义

在多核CPU中，存在多级缓存，其中L1和L2缓存是各核心独有，L3缓存所有核心共享。为了屏蔽这种硬件和操作系统的内存差异，JVM定义了JAVA内存模型。

1. 主内存：主内存是所有线程共享。负责存储所有可被多线程共享的变量，即实例字段、静态字段、构成数组对象的元素。主内存可类比硬件内存。

2. 工作内存：工作内存是各线程独有，保存被该线程使用到的变量的主内存副本拷贝。工作内存可类比CPU的L1、L2缓存。

**JMM规定，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程间也无法直接访问其工作内存中的变量值，变量值的传递均需要通过主内存完成。**

### 并发编程中的三个问题

1. 原子性：即一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 

2. 可见性：即当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改后的值。

3. 有序性：为了提高执行效率，Java允许对指令重排序。有序性指在指令重排序之后，程序执行的结果与按代码先后顺序的执行结果相同。

### JMM对原子性、可见性、有序性的保证

1. 原子性：JMM只保证基本读取和赋值（必须是将数字赋值给某个变量）是原子操作。同时，JMM提供synchronized和Lock来实现更大范围的原子性。

2. 可见性：JMM提供volatile关键字来保证。另外synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。

3. 有序性：JMM只保证单线程下代码的有序性，并不保证多线程下代码的有序性。

   此外，JMM具备一些先天的“有序性”，即happens-before原则（先行发生原则）：

   - 程序次序规则：单线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。

   - 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作。

   - volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。

     （即对volatile变量的写与随后对这个volatile变量的读之间不能进行指令重排序。这是JMM保证的，而不是volatile关键字保证的。）

   - 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则A先于C发生。

如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。如果需要更大规模的有序性，JMM提供volatile关键字，或者synchronized和Lock来实现。



## volatile关键字

### volatile不保证原子性

### volatile对可见性的保证

1. 当写一个volatile变量后，JMM会立即把该线程对应的工作内存中的共享变量值刷新到主内存中。

2. 当读一个volatile变量时， JMM会把该线程对应的工作内存中的值置为无效，强制线程从主内存中读取共享变量的值。

 **volatile对可见性保证的实现原理**

如果对声明了volatile变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，lock前缀的指令在多核处理器下会引发了两件事情。
- 将当前处理器缓存行的数据会写回到系统内存。
- 这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。

### volatile对有序性的保证

volatile关键字能禁止指令重排序，所以volatile在一定程度上保证了有序性。(volatile的happens-before规则)。

volatile关键字禁止指令重排序有两层意思：

  1. 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
  2. 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。

### volatile与锁的比较

锁保证了原子性、可见性、有序性。而volatile只保证了可见性、有序性，但没有保证原子性，所以volatile在多线程情况下不一定是安全的。

 volatile与CAS共同使用，可以实现乐观锁的功能。

### 使用volatile必须要同时满足两条规则（即需要保证操作是原子性操作）

1. 运算结果并不依赖变量的当前值，或者能够保证只有单一的线程修改变量的值。

2. 变量不需要与其他的状态变量共同参与不变约束。

###  volatile关键字的使用场景

1. 用于双重检查锁

   因为在new关键字创建对象时，会发生指令重排序现象（即设置instance引用指向创建的对象  和 Object对象的初始化两个指令会重排序）。所以会发生instance引用已经指向新创建的对象，而该对象还没有完成初始化工作的现象。所以instance变量需要用volatile修饰，禁止指令重排序。

   ```java
   public class DoubleCheckLocking {
   	private volatile static Object instance;
   
   	public static Object getInstance() {
   		if (instance == null) {
   			synchronized (DoubleCheckLocking.class) {
   				if (instance == null) {
   					instance = new Object();
   				}
   			}
   		}
   		return instance;
   	}
   }
   ```



## synchronized关键字

### synchronized锁的对象

在synchronized关键字中，Java中的所有对象都可以作为锁：

 - 对于普通同步方法，锁的是当前实例对象。
 - 对于静态同步方法，锁的是当前类的Class对象。
 - 对于同步方法块，锁的是synchronized括号中的对象。

### synchronized锁的4种状态

HotSpot虚拟机中，Java对象在内存中的布局包括对象头、实例数据和对齐填充。其中，对象头的内容如下：

![img](http://images2015.cnblogs.com/blog/731716/201703/731716-20170302104003563-2094361065.png)

在JDK1.6中，锁一共有4种状态，从低到高依次为：无锁状态、偏向锁、轻量级锁、重量级锁。锁的状态会随着竞争情况逐渐升级。锁可以升级但不能降级。

synchronized关键字用的锁就保存在对象头的MarkWord中。在运行期间，MarkWord中的数据会随着锁标志位的变化而变化。具体为：

![img](https://img-blog.csdn.net/20151217151455512?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)



#### 1. 偏向锁

由于大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得。

**偏向锁的特点：加解锁不需要额外的开销。偏向锁适用于没有多线程竞争同步代码块的情况**

如前所示，当锁标志位设置为偏向锁时，Java对象头的MarkWord中会保存当前锁偏向的线程ID。

1. 偏向锁获取过程：	
   1. 访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，确认为可偏向状态。
   2. 如果为可偏向状态，则通过CAS的方式将Mark Word中线程ID设置为当前线程。
   3. 如果CAS设置失败，说明存在多线程竞争锁。此时会在全局安全点（此时没有正在执行的字节码）时将获得偏向锁的线程挂起，然后偏向锁会升级为轻量级锁。之后获得偏向锁的线程继续往下执行同步代码。

2. 偏向锁的释放：偏向锁只有遇到存在多线程竞争锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。

#### 2. 轻量级锁（自旋锁）
**轻量级锁的特点：参与竞争的线程如果获取不到锁，会短暂自旋（继续占用CPU）而不是阻塞，避免线程切换的带来开销。轻量级锁适用于同步代码块执行时间短的情况。**

1. 轻量级锁的加锁过程
   1. 在线程进入同步块时，如果锁状态为无锁状态，虚拟机首先将在该线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。
   2. 拷贝锁对象头中的Mark Word复制到Lock Record空间中。
   3. 拷贝成功后，虚拟机将CAS的将锁对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向锁对象的mark word。如果更新成功，则执行步骤（4），否则执行步骤（5）。
   4. 如果更新成功，则表示该线程已经获取了锁，且锁对象Mark Word的锁标志位为轻量级锁定状态。
   5. 如果更新失败，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经获取了锁。否则说明存在多个线程竞争锁，此时该线程会进行短暂自旋并继续尝试获取锁。**如果自旋期间获取锁失败，则轻量级锁会膨胀为重量级锁**，（此时锁标志位设置为重量级锁，且Mark Word中存储的就是指向重量级锁（互斥量）的指针），之后该线程进入阻塞状态，后面如果再有争夺锁的线程也要进入阻塞状态。 

2. 轻量级锁的释放

   轻量级解锁时，会以CAS的方法将对象头的Mark Word中的值设置为Displaced Mark Word的值，如果成功，则表示同步过程已完成。如果失败，表示有其他线程尝试过获取该锁（此时对象头的MarkWord中锁标志位已更改为重量级锁），此时该线程就需要在释放锁的同时唤醒其他被阻塞的线程。

#### 3. 重量级锁



### Synchronized的其他优化

1、**适应性自旋（Adaptive Spinning）：**简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。

**2、锁粗化（Lock Coarsening）：**将多次连接在一起的加锁、解锁操作合并为一次，将多个连续的锁扩展成一个范围更大的锁。比如每次调用stringBuffer.append()方法都需要加锁和解锁，如果虚拟机检测到有一系列连串的对同一个对象加锁和解锁操作，就会将其合并成一次范围更大的加锁和解锁操作，即在第一次append方法时进行加锁，最后一次append方法结束后进行解锁。

**3、锁消除（Lock Elimination）：**即删除不必要的加锁操作。根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸出当前线程，那么可以认为这段代码是线程安全的，不必要加锁。



### Synchronized对原子性、可见性、有序性的保证

1. Synchronized保证多线程下临界区代码的原子性。

2. Synchronized对可见性的保证

  1. 当线程释放锁时，JMM将该线程对应的工作内存中的共享变量刷新到主内存中。
  2. 当线程获取锁时，JMM将该线程对应的工作内存中的共享变量置为无效。使临界区代码必须从主内存中获取共享变量。

3. Synchronized保证多线程下临界区代码的有序性