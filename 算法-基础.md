## 查找

### 二分查找 / 折半查找 
数组必须是有序的。    



### 包含重复值的二分查找

查找目标值第一次出现的下标

```java

public int binarySearch(int[] nums, int target) {
    if (nums == null || nums.length == 0) {
        return -1;
    }
    int start = 0;
    int end = nums.length - 1;
    while (start + 1 < end) {  //当start 和 end 相邻时，停止循环
        int mid = start + (end - start) / 2;
        if (nums[mid] == target) {
            end = mid;  //找到了一个target，让end = mid ，是为了使mid前移，来找到target第一次出现的下标
        } else if (nums[mid] < target) { //此时说明target在start的右边
            start = mid + 1;
        } else if (nums[mid] > target) {  //此时说明target在end的左边
            end = mid - 1;
        }
    }
    if (nums[start] == target) {
        return start;
    }
    if (nums[end] == target) {
        return end;
    }
    return -1;
}
```




## 排序

排序方法	平均时间	最好时间	最坏时间
桶排序(不稳定)	O(n)	O(n)	O(n)
基数排序(稳定)	O(n)	O(n)	O(n)



希尔排序(不稳定)	O(n^1.25)	 	 


直接插入排序(稳定)	O(n^2)	O(n)	O(n^2)

### 快速排序

快速排序是不稳定的排序算法。时间复杂度为：O(nlogn)、O(nlogn)、O(n^2)
最差时间复杂度发生是因为基准数选择不合理。比如基准数每次都是数组中最小的数，这时就需要比较n^2次

```java	
//每次选择一个基准数，并使基准数左边的数比基准数小，基准数右边的数比基准数大。
//然后以基准数为界，再分别递归基准数左边和基准数右边
public void quickSort(int[] nums, int left, int right) {
    if (left < right) {
        int i = left;
        int j = right;
        int x = nums[i]; //基准数
        while (i < j) {
            // 先从右边开始找比基准数小的数，并和nums[i]交换
            while (i < j && nums[j] >= x) {
                j--;
            }
            if (i < j) {
                nums[i] = nums[j];
                i++;
            }
            //再从左边开始找比基准数大的数，并和nums[j]交换
            while (i < j && nums[i] <= x) {
                i++;
            }
            if (i < j) {
                nums[j] = nums[i];
                j--;
            }
        }//每次循环结束后i与j肯定相等
        nums[i] = x;//基准数归位
        //基准数归位后，基准数左边的数肯定都比基准数小，基准数右边的数肯定都比基准数大

        quickSort(nums, left, i - 1);// 继续处理左边的，这里是一个递归的过程
        quickSort(nums, i + 1, right);// 继续处理右边的 ，这里是一个递归的过程
    }
}
```
### 堆排序（大顶堆）

```java
//堆排序(不稳定)	O(nlogn)	O(nlogn)	O(nlogn)
public void maxHeapify(int[] A, int i, int heapSize) {
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    int max = i;
    if (left < heapSize && A[left] > A[i]) {
        max = left;
    }
    if (right < heapSize && A[right] > A[max]) {
        max = right;
    }
    if (max != i) {
        swap(A, i, max);
        this.maxHeapify(A, max, heapSize);
    }
}
public void swap(int[] A, int i, int j) {
    int temp = A[i];
    A[i] = A[j];
    A[j] = temp;
}
void heapSort(int[] A) {
    //将数组构建成大顶堆
    for (int i = A.length / 2 - 1; i >= 0; i--) {
        maxHeapify(A, i, A.length);
    }
    //大顶堆构建成功后，堆顶元素是数组的最大值
    //这样每次将数组的最大值与最后一个元素交换，然后将剩下的元素再通过构建大顶堆来取出其中的最大值
    for (int i = A.length - 1; i > 0; i--) {
        swap(A, 0, i);
        //每次调整都是从根节点开始i不断减小，保证前一次最大节点不会参与到调整堆
        maxHeapify(A, 0, i);
    }
}
```

### 归并排序

```java
//归并排序(稳定)	O(nlogn)	O(nlogn)	O(nlogn)
public void merge(int[] nums, int first, int mid, int last, int[] sorted) {
    int i = first, j = mid;
    int k = 0;
    while (i < mid && j < last){
        if (nums[i] < nums[j]) {
            sorted[k++] = nums[i++];
        } else {
            sorted[k++] = nums[j++];
        }
    }
    while (i < mid) {
        sorted[k++] = nums[i++];
    }
    while (j < last) {
        sorted[k++] = nums[j++];
    }
    for (int v = 0; v < k; v++) {
        nums[first + v] = sorted[v];
    }
}
public void mergeSort(int[] nums, int first, int last, int[] sorted) {
    if (first + 1 < last) {
        int mid = (first + last) / 2;

        mergeSort(nums, first, mid, sorted);
        mergeSort(nums, mid, last, sorted);
        merge(nums, first, mid, last, sorted);
    }
}
```

### 插入排序

```java
//设有一组关键字｛K1， K2，…， Kn｝；排序开始就认为 K1 是一个有序序列；让 K2 插入上述表长为 1 的有序序列，
//使之成为一个表长为 2 的有序序列；；依次类推，最后得到一个表长为 n 的有序序列。
public void insertSort(int[] a) {
    for (int i = 1; i < a.length; i++) {
        int temp = a[i];      //先把a[i]取出来，因为后面可能会覆盖该位置
        int j;        //从i前一个数开始遍历，找到a[i]要插入的位置

        for (j = i - 1; j > -1; j--) {
            if (a[j] > temp) {   //如果a[j] > a[i]，则将a[j]后移，否则停止循环，a[i]就插入到此位置
                a[j + 1] = a[j];  //将前面较大的元素向后移动
            } else {
                break;
            }
        }
        a[j + 1] = temp;      //到达插入位置
    }
}
```



### 冒泡排序

```java
//冒泡排序(稳定)	O(n^2)	O(n)	O(n^2)
//冒泡排序是前后相邻的两个比较
public void bubbleSort(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        for (int j = 0; j < nums.length - 1; j++) { 
            if (nums[j] > nums[j + 1]) {
                int temp = nums[j];
                nums[j] = nums[j + 1];
                nums[j + 1] = temp;
            }
        }
    }
}
```

### 选择排序

```java
//选择排序(不稳定)	O(n^2)	O(n^2)	O(n^2)
//选择排序是从nums[i+1]到nums[nums.length-1]选出最小值，然后和nums[i]交换
public void selectionSort(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        int min = i;
        for (int j = i + 1; j < nums.length; j++) {
            if (nums[j] < nums[min]) { 
                min = j;
            }
        }
        if (min != i) {
            int temp = nums[i];
            nums[i] = nums[min];
            nums[min] = temp;
        }
    }
}
```



## 二叉树

### 层次遍历
```java
//	方法一：
public void levelOrder(TreeNode root) {
    if (root == null)
        return ;
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.add(root);

    while (queue.size() != 0) {
        TreeNode node = queue.poll();
        System.out.println(node.val);
        if (node.left != null) {
            queue.add(node.left);
        }
        if (node.right != null) {
            queue.add(node.right);
        }
    }
}

//方法二：
public void levelOrder(TreeNode root) {
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.add(root);
    while (queue.size() != 0) {
        TreeNode node = queue.poll();
        if (node != null) {
            System.out.println(node.val);
            queue.offer(node.left);
            queue.offer(node.right);
        }
    }
}
```

### 前序遍历（根左右）

```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<Integer>();

    if (root == null){
        return list;
    }
    Stack<TreeNode> s = new Stack<TreeNode>();
    s.push(root);
    while (s.size() != 0) {
        TreeNode node = s.pop();
        list.add(node.val);
        if (node.right != null) {
            s.push(node.right);
        }
        if (node.left != null) {
            s.push(node.left);
        }
    }
    return list;
}
```

### 中序遍历（左根右）

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<Integer>();
    TreeNode node = root;
    if (root == null)
        return list;
    Stack<TreeNode> s = new Stack<TreeNode>();

    while (s.size() != 0 || node != null) {
        while(node != null){
            s.push(node);
            node = node.left;
        }
        node = s.pop();
        list.add(node.val);
        node = node.right;
    }
    return list;
}
```

### 后序遍历（左右根）
```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    Deque<TreeNode> stack = new ArrayDeque<>();

    if (root == null) {
        return result;
    }

    TreeNode prev = null;
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode curr = stack.peek();
        if (prev == null || prev.left == curr || prev.right == curr) { //curr 向下走
            if (curr.left != null) {
                stack.push(curr.left);
            } else if (curr.right != null) {//
                stack.push(curr.right);
            }
        } else if (curr.left == prev) { //说明curr上次遍历的是它的左节点，所以应该跳到右节点
            if (curr.right != null) {
                stack.push(curr.right);
            }
        } else {//输出该节点
            result.add(curr.val);
            stack.pop();
        }
        prev = curr;
    }
    return result;
}
```





## 剑指Offer

### 单例模式

饿汉式在Class文件加载时就创建实例，所以创建实例的过程是安全的。但是饿汉式的创建方式在 Singleton 实例的创建需要依赖配置文件的情况下是无法使用的。

懒汉式-双重检验锁

```java
volatile private static MySingleton instance = null;   //使用volatile关键字保证其可见性
private MySingleton() { //构造方法私有化
}
public static MySingleton getInstance() {
    if (instance == null) {
        synchronized (MySingleton.class) {
            if (instance == null) {//二次检查
                instance = new MySingleton();
            }
        }
    }
    return instance;
}
```

懒汉式-枚举

枚举类的加载过程是线程安全的，可通过此特性构造线程安全的单例

```java
//构造单例
public class ClassFactory {
    private enum MyEnumSingleton {
        singletonFactory; //该枚举类的实例
        private Person instance; //每个枚举类都有的字段
        MyEnumSingleton() {//枚举类的构造方法在类加载是被实例化
            instance = new Person();
        }
        public Person getInstance() {
            return instance;
        }
    }
    public static Person getInstance() {
        return MyEnumSingleton.singletonFactory.getInstance();
    }
}
//获取单例
Object object = ClassFactory.getInstance()
```

### 数组中重复的数字

```java
//在一个长度为n的数组中，所有数字都在0~n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知
//道每个数字重复了几次。找出数组中任意一个重复的数字。

// 方法1：-->  采用Hash表
```

### 二维数组中的查找

```java
//在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。判断该数组中是否
//包含某特定数字。

//根据题目特点，需要从 右上角 或者 左下角 开始查找
public boolean Find(int target, int [][] array) {
    int i = 0;     //i指第0行
    int j = array[0].length-1;    //j指第 array[0].length-1 列
    while(i < array.length  && j > -1 ){
        if(target == array[i][j]){   //如果找到，直接返回true
            return true;
        }
        if(target < array[i][j]){ //
            j--;
        }else{
            i++;
        }
    }
    return false;
}
```

### 旋转数组中的最小数字

```java
//将一个数组最开始的几个元素搬到数组的末尾，称为数组的旋转。
//输入一个旋转排序数组，输出该旋转数组的最小值


/**
把一个排序数组先分割成两部分[first, second]，其中，first代表前面几个元素，second代表之后的元素，那么经过旋转之后，数组就变成了[second, first]。新数组有这样两个特性：（1）second中所有元素都大于first中任意元素（2）second与first都是递增的序列
*/
public int findMin(int[] nums) {
    int low = 0;
    int high = nums.length - 1;
    while (low < high && nums[low] >= nums[high]) {
        int mid = (low + high) / 2;
        if (nums[low] < nums[mid]) {
            low = mid + 1;  //左边需要 +1
        } else if (nums[low] > nums[mid]) {
            high = mid;
        } else {
            low = low + 1;
        }
    }
    return nums[low];
}
```



