## 使用缓存常见问题

### 缓存穿透

缓存穿透是指查询一个一定不存在的数据，如果在缓存中查不到就会到数据库中查，这样当访问量过大时，就造成数据库的压力过大，失去了缓存的意义。

解决办法：

1. 采用[布隆过滤器](https://www.baidu.com/s?wd=%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。
2. 如果一个查询返回的数据为空，则仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。

### 缓存雪崩

缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，这样请求全部转发到数据库，数据库瞬时压力过重雪崩。

解决办法：将缓存失效时间分散开，比如在原有的失效时间基础上增加一个1-5分钟的随机值，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。

### 缓存击穿

缓存击穿是指对于某些设置了过期时间的缓存，在过期时恰好被超高并发地访问，造成大量请求直接访问数据库，数据库的压力过大。

解决办法：

1. 互斥锁的方式：当缓存失效时，不是直接去数据库中读，而是先使用SETNX（SET if Not eXists，即只有不存在的时候才设置）获取锁。只有获取锁成功，才会去数据库中读取。否则就重试整个get缓存的方法。
2. 永不过期：“永不过期”包含两层意思：
   1. 从redis上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。
   2. 从功能上看，把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”不过期。



## 缓存一致性问题

淘汰缓存，而不是更新缓存

在1和2两个并发写发生时，由于无法保证时序，此时不管先操作缓存还是先操作数据库，都可能出现：
（1）请求1先操作数据库，请求2后操作数据库
（2）请求2先set了缓存，请求1后set了缓存
导致，数据库与缓存之间的数据不一致。
所以，Cache Aside Pattern建议，delete缓存，而不是set缓存。



**先操作数据库，再操作缓存**



如果先操作缓存。

在1和2并发读写发生时，由于无法保证时序，可能出现：
（1）写请求淘汰了缓存
（2）写请求操作了数据库（主从同步没有完成）
（3）读请求读了缓存（cache miss）
（4）读请求读了从库（读了一个旧数据）
（5）读请求set回缓存（set了一个旧数据）
（6）数据库主从同步完成
导致，数据库与缓存的数据不一致。



# Redis

Redis 是一个高性能的key-value数据库。

Redis 有以下三个特点：

- Redis支持数据的持久化，可以将内存中的数据保存在磁盘中。
- Redis有丰富的数据类型。
- Redis支持master-slave模式的数据备份。

## Redis 基础数据结构

Redis支持五种数据类型：string（字符串），hash表（哈希），list（列表），set（集合）及zset(有序集合)。Redis 所有的数据结构都是以唯一的 key 字符串作为名称，然后通过这个唯一 key 值来获取相应的 value值。所以Redis的数据类型均是指value值的类型。

- String类型：表示的是可变的字节数组。Redis 的String是动态字符串，是可以修改的字符串。String结构使用非常广泛，一个常见的用途就是 JSON 序列化的形式缓存用户信息。
- LIST类型：表示的是双向链表。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)。Redis 的List常用来做异步队列使用。将需要延后处理的任务序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理。
- SET类型：表示的是无序集合。它内部的键值对是无序且唯一的。它的内部实现相当于一个特殊的Hash类型，即所有的value都是NULL值。
- ZSET类型：表示的是有序集合。它给value都赋予一个 score，代表这个value的排序权重。它的内部是通过一种叫做**跳跃列表**的数据结构来实现的。
  zset 可以用来存粉丝列表，value 值是粉丝的用户 ID，score 是关注时间。我们可以对粉丝列表按关注时间进行排序。zset 还可以用来存储学生的成绩，value 值是学生的 ID，score 是他的考试成绩。我们可以对成绩按分数进行排序就可以得到他的名次。
- Hash表类型：表示的是包含键值对的无序散列表。基于数组加链表的二维结构实现。Redis中Hash类型的值只能是字符串。

### 键的过期时间

Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。

## Redis的应用

### 乐观锁

```bash
WATCH key # 监视key的状态，只有当被监视的Key没有被修改，事务才会执行。
MULTI # 标记一个事务块的开始。 随后的指令将在执行EXEC时作为一个原子执行

do-something... # 所有的命令都会进入事务队列，等待执行。

EXEC # 执行事务中所有在排队等待的指令并将链接状态恢复到正常 
```

### 分布式锁

分布式锁用于分布式系统中并发问题的处理。

```bash
#创建一个锁并设置过期时间，该命令是原子操作。设置过期时间保证了当执行异常出错时锁也会释放。
SET key value [EX seconds] [PX milliseconds] [NX|XX] 
# PX milliseconds：设置键key的过期时间，单位时毫秒
# NX ：只有键key不存在的时候才会设置key的值

> set lock true ex 5 nx 
OK
... do something critical ...
> del lock
```

 超时问题：Redis 的分布式锁不能解决超时问题，如果在加锁和释放锁之间的逻辑执行的太长，以至于超出了锁的超时限制，这时候前一个线程的逻辑还没有执行完，第二个线程就提前持有了这把锁，导致临界区代码不能得到严格的串行执行。为了避免这个问题，Redis 分布式锁不要用于较长时间的任务。如果真的偶尔出现了，数据出现的小波错乱可能需要人工介入解决

分布式锁的可重入性：Redis 分布式锁如果要支持可重入，需要使用线程的 Threadlocal 变量存储当前持有锁的计数。

### 延时队列

Redis 的 list(列表) 数据结构常用来作为异步消息队列使用，使用`rpush/lpush`操作入队列，使用`lpop 和 rpop`来出队列。

### 位图

位图就是将byte数组当成**位数组**操作。我们可以使用普通的 get/set 直接获取和设置整个位图的内容，也可以使用位图操作 getbit/setbit 等将 byte 数组看成「位数组」来处理。

### 布隆过滤器

Redis 官方提供的布隆过滤器到了 Redis 4.0 提供了插件功能之后才正式登场。布隆过滤器作为一个插件加载到 Redis Server 中，给 Redis 提供了强大的布隆去重功能。

```bash
bf.add：添加元素
bf.exists：查询元素是否存在，
```

### 发布订阅

```bash

```





## Redis的原理

### Redis事务的实现

### 跳跃列表的实现



### Redis数据持久化

#### RDB持久化

RDB持久化是指将某一个时间点的数据信息保存到RDB文件中，RDB文件是一个经过压缩的二进制文件。

RDB持久化可能会导致数据丢失。

RDB持久化操作可以手动执行，也可以配置服务器定期执行。其中有两个命令可以手动执行该操作：

1. SAVE命令：阻塞redis服务器进程，直到RDB文件创建完毕。
2. BGSAVE命令：派生一个子进程，由子进程负责创建RDB文件，父进程继续处理请求。

#### AOF持久化

AOF持久化通过将Redis服务器执行的写命令保存到AOF文件中来记录数据库状态。

AOF文件中的所有命令都以Redis命令请求协议的格式保存。在保存时，命令请求会先将命令保存到AOF缓冲区中，之后再定期写入到AOF文件。







