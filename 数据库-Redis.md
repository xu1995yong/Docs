## 使用缓存常见问题

### 缓存穿透

缓存穿透是指查询一个一定不存在的数据，如果在缓存中查不到就会到数据库中查，这样当访问量过大时，就造成数据库的压力过大，失去了缓存的意义。

解决办法：

1. 采用[布隆过滤器](https://www.baidu.com/s?wd=%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。
2. 如果一个查询返回的数据为空，则仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。

### 缓存雪崩

缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，这样请求全部转发到数据库，数据库瞬时压力过重雪崩。

解决办法：将缓存失效时间分散开，比如在原有的失效时间基础上增加一个1-5分钟的随机值，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。

### 缓存击穿

缓存击穿是指对于某些设置了过期时间的缓存，在过期时恰好被超高并发地访问，造成大量请求直接访问数据库，数据库的压力过大。

解决办法：

1. 互斥锁的方式：当缓存失效时，不是直接去数据库中读，而是先使用SETNX（SET if Not eXists，即只有不存在的时候才设置）获取锁。只有获取锁成功，才会去数据库中读取。否则就重试整个get缓存的方法。
2. 永不过期：“永不过期”包含两层意思：
   1. 从redis上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。
   2. 从功能上看，把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”不过期。



## 缓存一致性问题

淘汰缓存，而不是更新缓存

在1和2两个并发写发生时，由于无法保证时序，此时不管先操作缓存还是先操作数据库，都可能出现：
（1）请求1先操作数据库，请求2后操作数据库
（2）请求2先set了缓存，请求1后set了缓存
导致，数据库与缓存之间的数据不一致。
所以，Cache Aside Pattern建议，delete缓存，而不是set缓存。



**先操作数据库，再操作缓存**



如果先操作缓存。

在1和2并发读写发生时，由于无法保证时序，可能出现：
（1）写请求淘汰了缓存
（2）写请求操作了数据库（主从同步没有完成）
（3）读请求读了缓存（cache miss）
（4）读请求读了从库（读了一个旧数据）
（5）读请求set回缓存（set了一个旧数据）
（6）数据库主从同步完成
导致，数据库与缓存的数据不一致。



## 一致性Hash算法

简单来说，一致性哈希将整个哈希值空间组织成一个虚拟的圆环，**如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形）**。即可以将圆环分为2^32个节点。

下一步将各个服务器使用该Hash进行一个哈希，比如选择服务器的ip或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。

接下来使用如下算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。



当我们将node进行哈希后，这些值并没有均匀地落在环上，因此，最终会导致，这些节点所管辖的范围并不均匀，最终导致了数据分布的不均匀



# Redis

Redis 是一个高性能的key-value数据库。

Redis 有以下三个特点：

- Redis支持数据的持久化，可以将内存中的数据保存在磁盘中。
- Redis有丰富的数据类型。
- Redis支持master-slave模式的数据备份。

## Redis与memcache的比较

1. 数据类型

    - Redis支持的数据类型要丰富得多,Redis不仅仅支持简单的k/v类型的数据，同时还提供String，List,Set,Hash,Sorted Set,pub/sub,Transactions数据结构的存储。其中Set是HashMap实现的，value永远为null而已
    - memcache支持简单数据类型，需要客户端自己处理复杂对象 

2. 持久性

    - redis支持数据落地持久化存储,可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 

3. 分布式存储

    - Redis更偏向于在服务器端构建分布式存储，但没有采用一致性哈希。Redis Cluster是一个实现了分布式且允许单点故障的Redis高级版本，它没有中心节点，具有线性可伸缩的功能。为了保证单点故障下的数据可用性，Redis Cluster引入了Master节点和Slave节点。在Redis Cluster中，每个Master节点都会有对应的两个用于冗余的Slave节点。这样在整个集群中，任意两个节点的宕机都不会导致数据的不可用。当Master节点退出后，集群会自动选择一个Slave节点成为新的Master节点。
    - Memcached本身并不支持分布式，因此只能在客户端通过像一致性哈希这样的分布式算法来实现Memcached的分布式存储，当客户端向Memcached集群发送数据之前，首先会通过内置的分布式算法计算出该条数据的目标节点，然后数据会直接发送到该节点上存储。但客户端查询数据时，同样要计算出查询数据所在的节点，然后直接向该节点发送查询请求以获取数据。


4. Memcache支持多核多线程，Redis单线程操作







## Redis 基础数据结构

Redis支持五种数据类型：string（字符串），hash表（哈希），list（列表），set（集合）及zset(有序集合)。Redis 所有的数据结构都是以唯一的 key 字符串作为名称，然后通过这个唯一 key 值来获取相应的 value值。所以Redis的数据类型均是指value值的类型。

- String类型：表示的是可变的字节数组。Redis 的String是动态字符串，是可以修改的字符串。String结构使用非常广泛，一个常见的用途就是 JSON 序列化的形式缓存用户信息。
- LIST类型：表示的是双向链表。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)。Redis 的List常用来做异步队列使用。将需要延后处理的任务序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理。
- SET类型：表示的是无序集合。它内部的键值对是无序且唯一的。它的内部实现相当于一个特殊的Hash类型，即所有的value都是NULL值。
- ZSET类型：表示的是有序集合。它给value都赋予一个 score，代表这个value的排序权重。它的内部是通过一种叫做**跳跃列表**的数据结构来实现的。
  zset 可以用来存粉丝列表，value 值是粉丝的用户 ID，score 是关注时间。我们可以对粉丝列表按关注时间进行排序。zset 还可以用来存储学生的成绩，value 值是学生的 ID，score 是他的考试成绩。我们可以对成绩按分数进行排序就可以得到他的名次。
- Hash表类型：表示的是包含键值对的无序散列表。基于数组加链表的二维结构实现。Redis中Hash类型的值只能是字符串。

### 跳跃列表的实现

跳跃列表是一种随机化数据结构，实质对有序的链表增加上附加的前进链接，增加是以随机化的方式进行的，所以在列表中的查找可以快速的跳过部分列表元素。

比如在查找的过程中，可以先通过每个节点的最上层的指针先进行查找，如果未找到，则对下面一层的指针进行查找，若仍未找到，缩小范围继续查找。这样子就能跳过大部分的节点，缩短查询时间。

查找、插入和删除操作的时间复杂度都为: **O(logn)**

![img](https://img-blog.csdn.net/20150530162529554?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ195dWxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)



## Redis 中的缓存淘汰策略

### 键的过期时间

Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。

如何设置key的过期时间，通过以下的指令：

- EXPIRE 将key的生存时间设置为ttl秒 EXPIRE key ttl
- PEXPIRE 将key的生成时间设置为ttl毫秒
- EXPIREAT 将key的过期时间设置为timestamp所代表的的秒数的时间戳
- PEXPIREAT 将key的过期时间设置为timestamp所代表的的毫秒数的时间戳
- ttl key  可获得对应的key还有多少时间过期。

### Redis提供的几种淘汰策略

- noeviction：当内存使用达到阈值的时候，所有引起申请内存的命令会报错。是Redis默认的策略。
- allkeys-lru：在主键空间中，优先移除最近未使用的key。
- volatile-lru：在设置了过期时间的键空间中，优先移除最近未使用的key。
- allkeys-random：在主键空间中，随机移除某个key。
- volatile-random：在设置了过期时间的键空间中，随机移除某个key。
- volatile-ttl：在设置了过期时间的键空间中，具有更早过期时间的key优先移除。

### 策略适用的场景

- allkeys-lru：如果我们的应用对缓存的访问符合幂律分布（也就是存在相对热点数据），或者我们不太清楚我们应用的缓存访问分布状况，我们可以选择allkeys-lru策略。
- allkeys-random：如果我们的应用对于缓存key的访问概率相等，则可以使用这个策略。
- volatile-ttl：这种策略使得我们可以向Redis提示哪些key更适合被eviction。

另外，volatile-lru策略和volatile-random策略适合我们将一个Redis实例既应用于缓存和又应用于持久化存储的时候(存储一段时间)，然而我们也可以通过使用两个Redis实例来达到相同的效果，值得一提的是将key设置过期时间实际上会消耗更多的内存，因此我们建议使用allkeys-lru策略从而更有效率的使用内存。





## Redis的应用

### 乐观锁

```bash
WATCH key # 监视key的状态，只有当被监视的Key没有被修改，事务才会执行。
MULTI # 标记一个事务块的开始。 随后的指令将在执行EXEC时作为一个原子执行

do-something... # 所有的命令都会进入事务队列，等待执行。

EXEC # 执行事务中所有在排队等待的指令并将链接状态恢复到正常 
```

### 分布式锁

分布式锁用于分布式系统中并发问题的处理。

```bash
#创建一个锁并设置过期时间，该命令是原子操作。设置过期时间保证了当执行异常出错时锁也会释放。
SET key value [EX seconds] [PX milliseconds] [NX|XX] 
# PX milliseconds：设置键key的过期时间，单位时毫秒
# NX ：只有键key不存在的时候才会设置key的值

> set lock true ex 5 nx 
OK
... do something critical ...
> del lock
```

 超时问题：Redis 的分布式锁不能解决超时问题，如果在加锁和释放锁之间的逻辑执行的太长，以至于超出了锁的超时限制，这时候前一个线程的逻辑还没有执行完，第二个线程就提前持有了这把锁，导致临界区代码不能得到严格的串行执行。为了避免这个问题，Redis 分布式锁不要用于较长时间的任务。如果真的偶尔出现了，数据出现的小波错乱可能需要人工介入解决

分布式锁的可重入性：Redis 分布式锁如果要支持可重入，需要使用线程的 Threadlocal 变量存储当前持有锁的计数。

### 延时队列

Redis 的 list(列表) 数据结构常用来作为异步消息队列使用，使用`rpush/lpush`操作入队列，使用`lpop 和 rpop`来出队列。

### 位图

位图就是将byte数组当成**位数组**操作。我们可以使用普通的 get/set 直接获取和设置整个位图的内容，也可以使用位图操作 getbit/setbit 等将 byte 数组看成「位数组」来处理。

### 布隆过滤器

Redis 官方提供的布隆过滤器到了 Redis 4.0 提供了插件功能之后才正式登场。布隆过滤器作为一个插件加载到 Redis Server 中，给 Redis 提供了强大的布隆去重功能。

```bash
bf.add：添加元素
bf.exists：查询元素是否存在，
```

### 发布订阅

Redis 通过 [PUBLISH](http://redis.readthedocs.org/en/latest/pub_sub/publish.html#publish) 、 [SUBSCRIBE](http://redis.readthedocs.org/en/latest/pub_sub/subscribe.html#subscribe) 等命令实现了订阅与发布模式， 这个功能提供两种信息机制， 分别是订阅/发布到频道和订阅/发布到模式

```bash

```





## Redis事务的实现

Redis 通过 MULTI 、 DISCARD、 EXEC 和 WATCH 四个命令来实现事务功能。

- MULTI命令开始一个事务，即将客户端的 `REDIS_MULTI` 选项打开， 让客户端从非事务状态切换到事务状态。
- 客户端进入事务状态之后， 服务器在收到来自客户端的命令时， 不会立即执行命令， 而是将这些命令全部放进一个事务队列里， 然后返回 `QUEUED` ， 表示命令已入队。
- 但其实并不是所有的命令都会被放进事务队列， 其中的例外就是 [EXEC](http://redis.readthedocs.org/en/latest/transaction/exec.html#exec) 、 [DISCARD](http://redis.readthedocs.org/en/latest/transaction/discard.html#discard) 、 [MULTI](http://redis.readthedocs.org/en/latest/transaction/multi.html#multi) 和 [WATCH](http://redis.readthedocs.org/en/latest/transaction/watch.html#watch) 这四个命令 —— 当这四个命令从客户端发送到服务器时， 它们会像客户端处于非事务状态一样， 直接被服务器执行。
- 如果客户端正处于事务状态， 那么当 EXEC 命令执行时， 服务器根据客户端所保存的事务队列， 以先进先出（FIFO）的方式执行事务队列中的命令： 最先入队的命令最先执行， 而最后入队的命令最后执行。
- 执行事务中的命令所得的结果会以 FIFO 的顺序保存到一个回复队列中。
- 当事务队列里的所有命令被执行完之后， EXEC 命令会将回复队列作为自己的执行结果返回给客户端， 客户端从事务状态返回到非事务状态， 至此， 事务执行完毕。

DISCARD 命令用于取消一个事务， 它清空客户端的整个事务队列， 然后将客户端从事务状态调整回非事务状态， 最后返回字符串 `OK` 给客户端， 说明事务已被取消。

Redis 的事务是不可嵌套的， 当客户端已经处于事务状态， 而客户端又再向服务器发送 MULTI 时， 服务器只是简单地向客户端发送一个错误， 然后继续等待其他命令的入队。 MULTI 命令的发送不会造成整个事务失败， 也不会修改事务队列中已有的数据。

WATCH 命令用于在事务开始之前监视任意数量的键，当调用 EXEC 命令执行事务时， 如果任意一个被监视的键已经被其他客户端修改， 那整个事务不再执行， 直接返回失败。WATCH 只能在客户端进入事务状态之前执行， 在事务状态下发送 WATCH 命令会引发一个错误， 但它不会造成整个事务失败， 也不会修改事务队列中已有的数据（和前面处理 MULTI 的情况一样）





## Redis数据持久化

### RDB持久化

RDB持久化是指将某一个时间点的数据信息保存到RDB文件中，RDB文件是一个经过压缩的二进制文件。

RDB持久化可能会导致数据丢失。

RDB持久化操作可以手动执行，也可以配置服务器定期执行。其中有两个命令可以手动执行该操作：

1. SAVE命令：阻塞redis服务器进程，直到RDB文件创建完毕。
2. BGSAVE命令：派生一个子进程，由子进程负责创建RDB文件，父进程继续处理请求。

### AOF持久化

AOF持久化通过将Redis服务器执行的写命令保存到AOF文件中来记录数据库状态。

AOF文件中的所有命令都以Redis命令请求协议的格式保存。在保存时，命令请求会先将命令保存到AOF缓冲区中，之后再定期写入到AOF文件。



## Redis主从同步原理

和MySQL主从复制的原因一样，Redis虽然读取写入的速度都特别快，但是也会产生读压力特别大的情况。为了分担读压力，Redis支持主从复制，另外也是为了保证HA。Redis主从复制可以根据是否是全量分为全量同步和增量同步。

#### 全量同步

Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下： 

1. 从服务器连接主服务器，发送SYNC命令； 
2. 主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令； 
3. 主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； 
4. 从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； 
5. 主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； 
6. 从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令； 

#### 增量同步

Redis增量复制是指Slave正常工作时主服务器发生的写操作同步到从服务器的过程。 
增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。

Redis的同步策略是：主从刚刚连接的时候，进行全量同步；全量同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。



## Redis的哨兵机制

Redis-Sentinel也就是哨兵机制，是Redis官方推荐的高可用性(HA)解决方案，当用Redis做Master-slave的高可用方案时，Redis-sentinel能监控多个master-slave集群，发现master宕机后能进行自动切换。

它的主要功能有以下几点：

- 不时地监控redis是否按照预期良好地运行;
- 如果发现某个redis节点运行出现状况，能够通知另外一个进程(例如它的客户端);
- 能够进行自动切换（进行主备切换）。当一个master节点不可用时，能够选举出master的多个slave(如果有超过一个slave的话)中的一个来作为新的master,其它的slave节点会将它所追随的master的地址改为被提升为master的slave的新地址。

Sentinel支持集群
很显然，只使用单个sentinel进程来监控redis集群是不可靠的，当sentinel进程宕掉后(sentinel本身也有单点问题，single-point-of-failure)整个集群系统将无法按照预期的方式运行。所以有必要将sentinel集群，这样有几个好处：
即使有一些sentinel进程宕掉了，依然可以进行redis集群的主备切换；
如果只有一个sentinel进程，如果这个进程运行出错，或者是网络堵塞，那么将无法实现redis集群的主备切换（单点问题）;
如果有多个sentinel，redis的客户端可以随意地连接任意一个sentinel来获得关于redis集群中的信息。
Sentinel系统选举领头Sentinel的方法是RAFT算法。

