## 自我介绍

面试官你好，我叫徐勇。来自山东省莱芜市。我本科毕业于河南省平顶山学院，之后考入东北大学计算机科学与工程学院计算机技术专业，现在是一名研二的学生，将于2020年1月份毕业。由于我在学习期间对Java开发熟悉，所以希望能找一份Java开发实习的工作。在校期间，我主要完成了几个项目，一个是基于SpringBoot的秒杀系统的项目。这个项目是一个学习的项目。

因为现在大流量、高并发的需求非常多，所以我想学习一下业界在面对这种需求，他的主流的处理方式是怎样的。





## 系统压力测试

### 性能测试专业术语

**TPS**：Transactions Per Second（每秒传输的事物处理个数），即服务器**每秒**处理的事务数。TPS包括一条消息入和一条消息出，加上一次用户数据库访问。（业务TPS = CAPS × 每个呼叫平均TPS）

**QPS**：每秒查询率QPS是对一个特定的查询服务器在**规定时间内**所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。

### 测试结果

Jmeter

QPS：秒杀接口800，1000并发。4c4g。其他接口1100





## 限流算法

常用的限流算法有漏桶算法和令牌桶算法。

### 漏桶算法

原理：请求像一个水管里的水流一样注入到一个漏桶里，漏桶以恒定的速度往外漏水(无论进入的桶里的水流速度是多少)；当桶满了，水流则会溢出；这样当流量再大也会**以恒定的速度调用后台服务**，或者低于设定的速度(当请求流量不足时)；

优点：漏桶可以起到削峰，平滑请求的作用，

缺点：不能有效的利用系统资源，即时在系统可乘受住的峰值进入时，也不能加快处理请求，整体上会放缓系统对请求的处理速度。

### 令牌桶算法

原理：令牌桶是一个桶可以容纳有限的令牌，令牌是以固定的速度往令牌桶里不停的放，如果令牌桶满了，令牌着放不进去溢出；当有请求时，根据请求量去取相应的令牌数；

优点：相比漏桶，令牌桶允许一定的突发流量，限制后面请求的等待时间，来支持一定程度的突发请求，请求空闲时预热一部分令牌，新请求进来时无需等待。

缺点：代码实现相对复杂一些。

#### RateLimiter

guava的RateLimiter使用的是令牌桶算法，RateLimiter提供了acquire(阻塞)和tryAcquire(非阻塞)两种模式获取许可。



## 消息队列介绍

消息队列中间件是分布式系统中重要的组件，主要解决**应用解耦，异步消息，流量削锋**等问题，实现高性能，高可用，可伸缩和最终一致性架构。


1. 限流： 鉴于只有少部分用户能够秒杀成功，所以要限制大部分流量，只允许少部分流量进入服务后端。
2. 削峰：对于秒杀系统瞬时会有大量用户涌入，所以在抢购一开始会有很高的瞬间峰值。高峰值流量是压垮系统很重要的原因，所以如何把瞬间的高流量变成一段时间平稳的流量也是设计秒杀系统很重要的思路。实现削峰的常用的方法有利用缓存和消息中间件等技术。
3. 异步处理：秒杀系统是一个高并发系统，采用异步处理模式可以极大地提高系统并发量，其实异步处理就是削峰的一种实现方式。
4. 内存缓存：秒杀系统最大的瓶颈一般都是数据库读写，由于数据库读写属于磁盘IO，性能很低，如果能够把部分数据或业务逻辑转移到内存缓存，效率会有极大地提升。
5. 可拓展：当然如果我们想支持更多用户，更大的并发，最好就将系统设计成弹性可拓展的，如果流量来了，拓展机器就好了。像淘宝、京东等双十一活动时会增加大量机器应对交易高峰。


## 系统的架构





## 系统的优化措施

1. 秒杀地址隐藏：为了防止用户不断调用秒杀地址接口来，需要在秒杀开始时才创建商品秒杀的url，并保存在redis中。
2. 限流
3. 消息队列异步化订单处理过程
4. 数据库的乐观锁机制解决商品超卖问题



## 系统中的多重限流措施

1. 浏览器层：点击“秒杀按钮”以后，将按钮不可用，防止用户重复提交请求。JS也可以防止用户重复提交
2. Controller接口层限流：RateLimiter，快速失败。使用的是令牌桶算法，RateLimiter提供了acquire(阻塞)和tryAcquire(非阻塞)两种模式获取许可。
3. 使用redis的键的过期策略，秒杀时先将用户token作为键，存入redis中，并设置较短的过期时间。限制同一个uid访问频度
4. 集群层限流：Redis的decr命令原子性减库存。





采用Zookeeper分布式锁，解决多个请求更新缓存的问题。







## 系统中的缓存一致性

2. 订单事务失败后，立即置缓存失效
3. 缓存更新
   分布式锁

















### 针对热点商品的处理

#### 热点商品的高并发读

使用ehcache做多级缓存

EhCache 是一个纯Java的进程内缓存框架，ehcache直接在jvm虚拟机中缓存，速度快，效率高；但是缓存共享麻烦，集群分布式应用不方便。redis是通过socket访问到缓存服务，效率比ecache低，比数据库要快很多，处理集群和分布式缓存方便，有成熟的方案。

hcache支持3种缓存清除策略，如下所示：

- FIFO —— 先进先出 
  当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有element中，最先被put到cache中的那些element被remove掉。
- LFU —— Least Frequently Used，最少使用频率。 
  基于计数的算法。每个element被put到cache时，都会有一个hitCount成员变量用于计数，初始值为0。每次从cache中get一个element时，该element的hitCount值加1。 
  当缓存容量满了，而又需要腾出地方来缓存新的元素时，现有element中，hitCount最小的元素将被remove掉。
- LRU —— Least Recently Used, 最近最少使用。 
  ehcache默认的缓存清除策略。每个element有一个lastAccessTime，当一个element被put到cache时，lastAccessTime被赋为当前时间值。随后每次从cache中get出该element时，lastAccessTime又会被更新为当前时间值。 
  当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有element中，lastAccessTime最小的一些元素将被remove掉。



#### 热点商品的高并发写

秒杀过程中，某些热点商品会存在高并发的库存修改问题，此时会有大量的线程来竞争InnoDB中该商品所在行的行锁。这样数据库的性能受到很大的影响，其他商品的秒杀行为也会受到影响，即0.01%商品影响99.99%的商品。



## 如何判断秒杀成功

1. 前台轮询订单信息：主流做法
2. WebSocket：服务端维护很多长连接也是挺耗费资源的，服务器集群以及览器或者客户端兼容性问题，也会带来了一些不确定性因素