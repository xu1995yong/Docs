![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20170328082725339?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTc3NDUxNw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

## TCP与UDP区别

1. TCP面向连接，比如三握四挥；UDP是无连接的，即发送数据之前不需要建立连接
2. TCP提供可靠的服务。通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，不保证可靠交付
3. TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的
4. TCP基于可靠通信，有确认机制，有拥塞控制算法。UDP没有确认机制和拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
5. 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
6. TCP首部开销20字节；UDP的首部开销小，只有8个字节

## TCP与UDP的用途

TCP是面向连接的，有比较高的可靠性，一些要求比较高的服务一般使用这个协议，如FTP、Telnet、SMTP、HTTP、POP3等，**文本、程序、文件等要求可靠的数据**

而UDP是面向无连接的，使用这个协议的常见服务有DNS、SNMP、视频聊天语音聊天基本都是用UPD协议。 



## TCP的三握握手

假设有服务器A和服务器B，其中服务器B处于Listen状态。

1. 服务器A想服务器B发送连接请求报文段，即报文中的同步位SYN=1，初始序号seq=x。SYN=1的报文段不能携带数据，但需要消耗一个序号。
2. 服务器B收到连接请求报文段后，如同意建立连接，则发送确认报文段。即报文段中SYN=1，ACK=1，初始序号seq=y，确认号ack=x+1，该报文段的目的不仅是确认报文，还有同步服务器B的序号。确认报文段同样不能携带数据。
3. 服务器A收到服务器B的确认连接报文后，还要向B发送确认报文段。即报文段中ACK=1，seq=x+1，ack=y+1，

### 为什么需要三次握手

主要是为了防止服务器A发送的已失效的连接请求报文段突然又传送到服务器B。即服务器A发送连接请求，但是因为网络原因服务器B并没有收到，于是服务器A重新发送连接请求，服务器B收到了第二次发送的连接请求，于是建立连接。数据传输完毕后释放连接。此时如果服务器A发送的第一个请求报文到达服务器B，如果不需要三次握手的话，服务器B收到该请求报文就会建立连接。

## TCP的四次挥手

A--->B：

1. 服务器A向服务器B发送连接释放报文，报文首部的终止控制位FIN=1，序号seq=u，此时服务器A进去FIN-WAIT-1状态。
2. 服务器B收到服务器A的连接释放报文后，发送确认报文，seq=v，ACK=1，ack=u+1。此时服务器A到B方向的连接释放，服务器B进入CLOSE-WAIT状态。
3. 服务器A收到服务器B的确认后，进入FIN-WAIT-2状态。

B--->A：

1. 服务器B向服务器A发送连接释放报文，报文首部的终止控制位FIN=1，seq=w，而且确认号ack=u+1。此时服务器B进入LAST-ACK状态。
2. 服务器A收到服务器B的连接释放报文后，发送确认报文，seq=u+1，ACK=1，ack=w+1，之后服务器A进入TIME-WAIT状态。注意，此时TCP连接还未释放，必须经过TIME-WAIT timer时间后才进入CLOSE状态

### 为什么需要等待2MSL

1. 为了保证服务器A发送的最后一个ACK报文能够到达B。如果在此时间内服务器B没有收到服务器A的确认报文，就会重发FIN报文。如果没有等待时间的话，服务器B就无法正常进入CLOSED状态。
2. 同上防止本连接的连接请求报文出现在再下一个连接中。

### 为什么需要四次挥手

因为TCP是全双工的，

## TCP的几种状态

**LISTENING：**侦听来自远方的TCP端口的连接请求。服务端需要打开一个**socket**进行监听，状态为LISTEN。看LISTENING状态最主要的是看本机开了哪些端口，

**SYN-SENT：客户端状态SYN_SENT：**客户端tcp发送一个SYN以请求建立一个连接.之后状态置为SYN_SENT. 

**SYN-RECEIVED：服务器端状态SYN_RCVD**： 当服务器收到客户端发送的同步信号时，将标志位ACK和SYN置1发送给客户端，此时服务器端处于SYN_RCVD状态，如果连接成功了就变为ESTABLISHED。

**ESTABLISHED：代表一个打开的连接**：ESTABLISHED状态是表示两台机器正在传输数据，观察这个状态最主要的就是看哪个程序正在处于ESTABLISHED状态。 netstat -nat |grep 9502或者使用lsof  -i:9502可以检测到。


**FIN-WAIT-1：**主动关闭端应用程序调用close，于是其TCP发出FIN请求主动关闭连接，之后进入FIN_WAIT1状态。

**FIN-WAIT-2：**主动关闭端接到ACK后，就进入了FIN-WAIT-2。这就是著名的半关闭的状态了，这是在关闭连接时，客户端和服务器两次握手之后的状态。在这个状态下，应用程序还有接受数据的能力，但是已经无法发送数据。

**CLOSE-WAIT：**被动关闭端TCP接到FIN后，就发出ACK以回应FIN请求,并进入CLOSE_WAIT。

**LAST-ACK：**被动关闭端的TCP发送一个 FIN,等待对方的ACK，此时就进入了LAST-ACK 。

**TIME-WAIT：**在主动关闭端接收到FIN后，TCP就发送ACK包，并进入TIME-WAIT状态。TIME_WAIT等待状态，这个状态又叫做2MSL状态，说的是在TIME_WAIT2发送了最后一个ACK数据报以后，要进入TIME_WAIT状态，这个状态是防止最后一次握手的数据报没有传送到对方那里而准备的

**CLOSED：**被动关闭端在接受到ACK包后，就进入了closed的状态。连接结束。

## TCP的可靠传输的实现

1. 首先，采用三次握手来建立TCP连接，四次握手来释放TCP连接，从而保证建立的传输信道是可靠的。
2. 其次，TCP采用了连续ARQ协议（回退N，Go-back-N；超时自动重传）来保证数据传输的正确性，使用滑动窗口协议来保证接方能够及时处理所接收到的数据，进行流量控制。
3. 最后，TCP使用慢开始、拥塞避免、快重传和快恢复来进行拥塞控制，避免网络拥塞。






## TCP的拥塞控制算法

TCP中的拥塞控制都是基于窗口的拥塞控制。发送方维持一个拥塞窗口cwnd，并且使自己的发送窗口等于拥塞窗口。判断网络拥塞的依据就是出现了超时。

TCP中有四种拥塞控制算法，即：

1. 慢开始：即当主机开始发送数据时，或者拥塞窗口小于慢开始门限，由小到大逐渐增大发送窗口。在刚开始发送时，将拥塞窗口设为1-2个SMSS的值，在每次收到一个对新报文的确认后，就可以把拥塞窗口增加一个SMSS的数值。
2. 拥塞避免：为了防止拥塞窗口增长过快导致网络拥塞， 当cwnd的值大于慢开始门限值时，开始使用拥塞避免算法。即每经过一个往返时间RTT才把拥塞窗口加1，而不是向慢开始阶段的加倍增长。
3. 快重传：指接收方在收到报文后必须立即发送确认，即使收到失序报文段也要对已收到的报文的重复确认。然后发送方收到重复确认报文后，就可以立即对丢失的报文进行重传。
4. 快恢复：指当发送方连续收到三个重复确认后，认为网络很可能没有发生拥塞，于是不执行慢开始算法，而是将慢开始门限值减半，同时将拥塞窗口值置为新的慢开始门限值，然后开始执行拥塞避免算法。所以，**当采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络超时时才使用。**



## DNS协议





## HTTP协议

HTTP协议即超文本传输协议，主要用途是从服务器传输超文本到本地浏览器，特点是简单灵活、无状态。

### HTTP请求报文

HTTP请求报文包括以下格式：请求行、请求头、空行、请求数据

常见的请求方法有四种：`GET`，`POST`，`PUT`，`DELETE`。其中：GET请求用于信息获取，应该是安全的和幂等的。POST请求可能修改变服务器上的资源。



![img](https://upload-images.jianshu.io/upload_images/2964446-fdfb1a8fce8de946.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/466/format/webp)



![âhttp è¯·æ±âçå¾çæç´¢ç"æ](https://upload-images.jianshu.io/upload_images/1461379-e27e2159621a6020.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/897/format/webp)



### HTTP响应报文

HTTP响应报文包含三个部分：状态行、响应头、空行、响应正文。

其中状态行由HTTP协议版本号， 状态码， 状态消息 三部分组成。





#### HTTP响应报文的状态码

状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:

- 1xx：指示信息--表示请求已接收，继续处理
- 2xx：成功--表示请求已被成功接收、理解、接受
- 3xx：重定向--要完成请求必须进行更进一步的操作
- 4xx：客户端错误--请求有语法错误或请求无法实现
- 5xx：服务器端错误--服务器未能实现合法的请求

常见状态码：

```java
200 OK                        //客户端请求成功
400 Bad Request               //客户端请求有语法错误，不能被服务器所理解
401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 
403 Forbidden                 //服务器收到请求，但是拒绝提供服务
404 Not Found                 //请求资源不存在，eg：输入了错误的URL
500 Internal Server Error     //服务器发生不可预期的错误
503 Server Unavailable    
```




![img](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1552103205074&di=dc4055dd5e35ab8101feb2d8ec0c2036&imgtype=0&src=http%3A%2F%2Fs8.51cto.com%2Fwyfs01%2FM01%2F17%2F9A%2FwKioOVIgN5ngpbouAABR5IbM_Nw836.jpg)





### HTTP协议的版本

#### HTTP/1.0

HTTP 1.0默认使用短连接，即浏览器的每次请求都需要与服务器建立TCP连接，服务器完成请求处理后立即断开TCP连接。这样导致连接无法复用，耗费资源和性能。如果需要在HTTP1.0中使用长连接，需要添加请求头 Connection: Keep-Alive。

#### HTTP/1.1

HTTP 1.1默认使用长连接。

HTTP 1.1采用分块传输的机制，即产生一块数据，就发送一块。而不是等待所有操作完成后才统一返回数据。

#### HTTP/2.0

采用多路复用的方式，加快数据传输速度。

启用头部压缩。当我们不断地从同一个客户端访问服务器时，有很多重复的数据比如 cookie 数据，会在请求头上反复发送，增加带宽的使用以及延迟。为了解决这个问题，HTTP/2 引入了头压缩。所有头信息都会放在一张表里面，由客户端和服务器共同维护，随后的请求中省略任何重复的标题，使用一个索引号，服务端根据索引号从维护的表中引用它们。