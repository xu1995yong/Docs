![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20170328082725339?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTc3NDUxNw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


## TCP报文格式
TCP封装在IP报文中的时候，如下图所示，TCP头紧接着IP头(IPV6有扩展头的时候，则TCP头在扩展头后面)，不携带选项(option)的TCP头长为20bytes，携带选项的TCP头最长可到60bytes。其中header length字段由4比特构成，最大值为15，单位是32比特，即头长的最大值为15*32 bits = 60bytes，因此上面说携带选项的TCP头长最长为60bytes。 
TCP的源端口、目的端口、以及IP层的源IP地址、目的IP地址四元组唯一的标识了一个TCP连接
![img](https://img-blog.csdn.net/20170726140929868?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWFyeXdhbmc1Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
TCP各字段释义： 
TCP源端口(Source Port)：16位的源端口其中包含发送方应用程序对应的端口。源端口和源IP地址标示报文发送端的地址。 
TCP目的端口(Destination port)：16位的目的端口域定义传输的目的。这个端口指明报文接收计算机上的应用程序地址接口。 
TCP序列号（SequenceNumber）：32位的序列号标识了TCP报文中第一个byte在对应方向的传输中对应的字节序号。当SYN出现，SN=ISN(随机值）单位是byte。比如发送端发送的一个TCP包净荷(不包含TCP头)为12byte，SN为5，则发送端接着发送的下一个数据包的时候，SN应该设置为5+12=17。通过序列号，TCP接收端可以识别出重复接收到的TCP包，从而丢弃重复包，同时对于乱序数据包也可以依靠系列号进行重排序，进而对高层提供有序的数据流。另外如果接收的包中包含SYN或FIN标志位，逻辑上也占用1个byte，应答号需加1。 
TCP应答号(Acknowledgment Number简称ACK Number)：32位的ACK Number标识了报文发送端期望接收的字节序列。如果设置了ACK控制位，这个值表示一个准备接收的包的序列码，注意是准备接收的包，比如当前接收端接收到一个净荷为12byte的数据包，SN为5，则会回复一个确认收到的数据包，如果这个数据包之前的数据也都已经收到了，这个数据包中的ACK Number则设置为12+5=17，表示之前的数据都已经收到了，准备接受SN=17的数据包。

注：关于TCP序列号和应答号，也可以参考文章：http://blog.csdn.net/a19881029/article/details/38091243/

头长(Header Length)：4位包括TCP头大小，指示TCP头的长度，即数据从何处开始。

保留(Reserved)：4位值域，这些位必须是0。为了将来定义新的用途所保留，其中RFC3540将Reserved字段中的最后一位定义为Nonce标志。后续拥塞控制部分的讲解我们会简单介绍Nonce标志位。

标志(Code Bits)：8位标志位，下面介绍。

窗口大小(Window Size)：16位，该值指示了从Ack Number开始还愿意接收多少byte的数据量，也即用来表示当前接收端的接收窗还有多少剩余空间，用于TCP的流量控制。

校验位(Checksum)：16位TCP头。发送端基于数据内容计算一个数值，接收端要与发送端数值结果完全一样，才能证明数据的有效性。接收端checksum校验失败的时候会直接丢掉这个数据包。CheckSum是根据伪头+TCP头+TCP数据三部分进行计算的。

优先指针（紧急,Urgent Pointer）：16位，指向后面是优先数据的字节，在URG标志设置了时才有效。如果URG标志没有被设置，紧急域作为填充。 
选项(Option)：长度不定，但长度必须以是32bits的整数倍。常见的选项包括MSS、SACK、Timestamp等等。

八位标志位分别介绍如下：

CWR(Congestion Window Reduce)：拥塞窗口减少标志set by sender，用来表明它接收到了设置ECE标志的TCP包。并且sender 在收到消息之后已经通过降低发送窗口的大小来降低发送速率。

ECE(ECN Echo)：ECN响应标志被用来在TCP3次握手时表明一个TCP端是具备ECN功能的。在数据传输过程中也用来表明接收到的TCP包的IP头部的ECN被设置为11。注：IP头部的ECN被设置为11表明网络线路拥堵。

注：关于CWR和ECE标记为详细信息可参考：http://www.cnblogs.com/hadis-yuki/p/5467787.html

URG(Urgent)：该标志位置位表示紧急(The urgent pointer) 标志有效。该标志位目前已经很少使用参考后面流量控制和窗口管理部分的介绍。

ACK：取值1代表Acknowledgment Number字段有效，这是一个确认的TCP包，取值0则不是确认包。后续文章介绍中当ACK标志位有效的时候我们称呼这个包为ACK包，使用大写的ACK称呼。

PSH(Push)：该标志置位时，一般是表示发送端缓存中已经没有待发送的数据，接收端不将该数据进行队列处理，而是尽可能快将数据转由应用处理。在处理 telnet 或 rlogin 等交互模式的连接时，该标志总是置位的。

RST(Reset)：用于reset相应的TCP连接。通常在发生异常或者错误的时候会触发复位TCP连接。

SYN：同步序列编号(Synchronize Sequence Numbers)有效。该标志仅在三次握手建立TCP连接时有效。

FIN(Finish)：No more data from sender。当FIN标志有效的时候我们称呼这个包为FIN包。

## TCP与UDP区别

1. TCP面向连接，比如三握四挥；UDP是无连接的，即发送数据之前不需要建立连接
2. TCP提供可靠的服务。通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，不保证可靠交付
3. TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的
4. TCP基于可靠通信，有确认机制，有拥塞控制算法。UDP没有确认机制和拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
5. 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
6. TCP首部开销20字节；UDP的首部开销小，只有8个字节

### 面向报文（UDP）和面向字节流（TCP）的区别

面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。 
面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。

## TCP与UDP的用途

TCP是面向连接的，有比较高的可靠性，一些要求比较高的服务一般使用这个协议，如FTP、Telnet、SMTP、HTTP、POP3等，**文本、程序、文件等要求可靠的数据**

而UDP是面向无连接的，使用这个协议的常见服务有DNS、SNMP、视频聊天语音聊天基本都是用UPD协议。 



## TCP的三握握手

假设有服务器A和服务器B，其中服务器B处于Listen状态。

1. 服务器A想服务器B发送连接请求报文段，即报文中的同步位SYN=1，初始序号seq=x。SYN=1的报文段不能携带数据，但需要消耗一个序号。
2. 服务器B收到连接请求报文段后，如同意建立连接，则发送确认报文段。即报文段中SYN=1，ACK=1，初始序号seq=y，确认号ack=x+1，该报文段的目的不仅是确认报文，还有同步服务器B的序号。确认报文段同样不能携带数据。
3. 服务器A收到服务器B的确认连接报文后，还要向B发送确认报文段。即报文段中ACK=1，seq=x+1，ack=y+1，

### 为什么需要三次握手

主要是为了防止服务器A发送的已失效的连接请求报文段突然又传送到服务器B。即服务器A发送连接请求，但是因为网络原因服务器B并没有收到，于是服务器A重新发送连接请求，服务器B收到了第二次发送的连接请求，于是建立连接。数据传输完毕后释放连接。此时如果服务器A发送的第一个请求报文到达服务器B，如果不需要三次握手的话，服务器B收到该请求报文就会建立连接。

## TCP的四次挥手

A--->B：

1. 服务器A向服务器B发送连接释放报文，报文首部的终止控制位FIN=1，序号seq=u，此时服务器A进去FIN-WAIT-1状态。
2. 服务器B收到服务器A的连接释放报文后，发送确认报文，seq=v，ACK=1，ack=u+1。此时服务器A到B方向的连接释放，服务器B进入CLOSE-WAIT状态。
3. 服务器A收到服务器B的确认后，进入FIN-WAIT-2状态。

B--->A：

1. 服务器B向服务器A发送连接释放报文，报文首部的终止控制位FIN=1，seq=w，而且确认号ack=u+1。此时服务器B进入LAST-ACK状态。
2. 服务器A收到服务器B的连接释放报文后，发送确认报文，seq=u+1，ACK=1，ack=w+1，之后服务器A进入TIME-WAIT状态。注意，此时TCP连接还未释放，必须经过TIME-WAIT timer时间后才进入CLOSE状态

### 为什么需要等待2MSL

1. 为了保证服务器A发送的最后一个ACK报文能够到达B。如果在此时间内服务器B没有收到服务器A的确认报文，就会重发FIN报文。如果没有等待时间的话，服务器B就无法正常进入CLOSED状态。
2. 同上防止本连接的连接请求报文出现在再下一个连接中。

### 为什么需要四次挥手

因为TCP是全双工的，

## TCP的几种状态

**LISTENING：**侦听来自远方的TCP端口的连接请求。服务端需要打开一个**socket**进行监听，状态为LISTEN。看LISTENING状态最主要的是看本机开了哪些端口，

**SYN-SENT：客户端状态SYN_SENT：**客户端tcp发送一个SYN以请求建立一个连接.之后状态置为SYN_SENT. 

**SYN-RECEIVED：服务器端状态SYN_RCVD**： 当服务器收到客户端发送的同步信号时，将标志位ACK和SYN置1发送给客户端，此时服务器端处于SYN_RCVD状态，如果连接成功了就变为ESTABLISHED。

**ESTABLISHED：代表一个打开的连接**：ESTABLISHED状态是表示两台机器正在传输数据，观察这个状态最主要的就是看哪个程序正在处于ESTABLISHED状态。 netstat -nat |grep 9502或者使用lsof  -i:9502可以检测到。


**FIN-WAIT-1：**主动关闭端应用程序调用close，于是其TCP发出FIN请求主动关闭连接，之后进入FIN_WAIT1状态。

**FIN-WAIT-2：**主动关闭端接到ACK后，就进入了FIN-WAIT-2。这就是著名的半关闭的状态了，这是在关闭连接时，客户端和服务器两次握手之后的状态。在这个状态下，应用程序还有接受数据的能力，但是已经无法发送数据。

**CLOSE-WAIT：**被动关闭端TCP接到FIN后，就发出ACK以回应FIN请求,并进入CLOSE_WAIT。

**LAST-ACK：**被动关闭端的TCP发送一个 FIN,等待对方的ACK，此时就进入了LAST-ACK 。

**TIME-WAIT：**在主动关闭端接收到FIN后，TCP就发送ACK包，并进入TIME-WAIT状态。TIME_WAIT等待状态，这个状态又叫做2MSL状态，说的是在TIME_WAIT2发送了最后一个ACK数据报以后，要进入TIME_WAIT状态，这个状态是防止最后一次握手的数据报没有传送到对方那里而准备的

**CLOSED：**被动关闭端在接受到ACK包后，就进入了closed的状态。连接结束。

## TCP的可靠传输的实现

1. 首先，采用三次握手来建立TCP连接，四次握手来释放TCP连接，从而保证建立的传输信道是可靠的。
2. 其次，TCP采用了连续ARQ协议（回退N，Go-back-N；超时自动重传）来保证数据传输的正确性，使用滑动窗口协议来保证接方能够及时处理所接收到的数据，进行流量控制。
3. 最后，TCP使用慢开始、拥塞避免、快重传和快恢复来进行拥塞控制，避免网络拥塞。






## TCP的拥塞控制算法

TCP中的拥塞控制都是基于窗口的拥塞控制。发送方维持一个拥塞窗口cwnd，并且使自己的发送窗口等于拥塞窗口。判断网络拥塞的依据就是出现了超时。

TCP中有四种拥塞控制算法，即：

1. 慢开始：即当主机开始发送数据时，或者拥塞窗口小于慢开始门限，由小到大逐渐增大发送窗口。在刚开始发送时，将拥塞窗口设为1-2个SMSS的值，在每次收到一个对新报文的确认后，就可以把拥塞窗口增加一个SMSS的数值。
2. 拥塞避免：为了防止拥塞窗口增长过快导致网络拥塞， 当cwnd的值大于慢开始门限值时，开始使用拥塞避免算法。即每经过一个往返时间RTT才把拥塞窗口加1，而不是向慢开始阶段的加倍增长。
3. 快重传：指接收方在收到报文后必须立即发送确认，即使收到失序报文段也要对已收到的报文的重复确认。然后发送方收到重复确认报文后，就可以立即对丢失的报文进行重传。
4. 快恢复：指当发送方连续收到三个重复确认后，认为网络很可能没有发生拥塞，于是不执行慢开始算法，而是将慢开始门限值减半，同时将拥塞窗口值置为新的慢开始门限值，然后开始执行拥塞避免算法。所以，**当采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络超时时才使用。**



## DNS协议

DNS提供将主机名和域名转换为IP地址的工作。他应用层协议工作的，包括不限于HTTP和SMTP以及FTP，用于将用户提供的主机名解析为ip地址。其具体的流程可描述如下：

1. 主机10.74.36.90先向本地域名服务器10.74.1.11进行**递归查询**
2. 本地域名服务器采用**迭代查询**，向一个根域名服务器进行查询
3. 根域名服务器告诉本地域名服务器，下一次应该查询的顶级域名服务器` dns.me`的IP地址
4. 本地域名服务器向顶级域名服务器 `dns.me`进行查询
5. 顶级域名服务器`me`告诉本地域名服务器，下一步查询权限服务器`dns.jocent.me` 的IP地址
6. 本地域名服务器向权限服务器 ```dns.jocent.me`进行查询
7. 权限服务器 `dns.jocent.me`告诉本地域名服务器所查询的主机的IP地址
8. 本地域名服务器最后把查询结果告诉 10.74.36.90





- **递归查询：**本机向本地域名服务器发出一次查询请求，就静待最终的结果。如果本地域名服务器无法解析，自己会以DNS客户机的身份向其它域名服务器查询，直到得到最终的IP地址告诉本机
- **迭代查询：**本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，每次它都是以客户机的身份去各个服务器查询



## HTTP协议

HTTP协议即超文本传输协议，主要用途是从服务器传输超文本到本地浏览器，特点是简单灵活、无状态。

### HTTP请求报文

HTTP请求报文包括以下格式：请求行、请求头、空行、请求数据

常见的请求方法有四种：`GET`，`POST`，`PUT`，`DELETE`。其中：GET请求用于信息获取，应该是安全的和幂等的。POST请求可能修改变服务器上的资源。



![img](https://upload-images.jianshu.io/upload_images/2964446-fdfb1a8fce8de946.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/466/format/webp)



![âhttp è¯·æ±âçå¾çæç´¢ç"æ](https://upload-images.jianshu.io/upload_images/1461379-e27e2159621a6020.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/897/format/webp)



### HTTP响应报文

HTTP响应报文包含三个部分：状态行、响应头、空行、响应正文。

其中状态行由HTTP协议版本号， 状态码， 状态消息 三部分组成。





#### HTTP响应报文的状态码

状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:

- 1xx：指示信息--表示请求已接收，继续处理
- 2xx：成功--表示请求已被成功接收、理解、接受
- 3xx：重定向--要完成请求必须进行更进一步的操作
- 4xx：客户端错误--请求有语法错误或请求无法实现
- 5xx：服务器端错误--服务器未能实现合法的请求

常见状态码：

```java
200 OK                        //客户端请求成功
400 Bad Request               //客户端请求有语法错误，不能被服务器所理解
401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 
403 Forbidden                 //服务器收到请求，但是拒绝提供服务
404 Not Found                 //请求资源不存在，eg：输入了错误的URL
500 Internal Server Error     //服务器发生不可预期的错误
503 Server Unavailable    
```




![img](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1552103205074&di=dc4055dd5e35ab8101feb2d8ec0c2036&imgtype=0&src=http%3A%2F%2Fs8.51cto.com%2Fwyfs01%2FM01%2F17%2F9A%2FwKioOVIgN5ngpbouAABR5IbM_Nw836.jpg)

### HTTP 协议包括哪些请求

- GET：对服务器资源的简单请求
- POST：用于发送包含用户提交数据的请求
- HEAD：类似于GET请求，不过返回的响应中没有具体内容，用于获取报头
- PUT：传说中请求文档的一个版本
- DELETE：发出一个删除指定文档的请求
- TRACE：发送一个请求副本，以跟踪其处理进程
- OPTIONS：返回所有可用的方法，检查服务器支持哪些方法
- CONNECT：用于ssl隧道的基于代理的请求

#### HTTP中GET和POST的区别

从原理性看：

- 根据HTTP规范，GET用于信息获取，而且应该是安全和幂等的
- 根据HTTP规范，POST请求表示可能修改服务器上资源的请求

从表面上看：

- GET请求的数据会附在URL后面，POST的数据放在HTTP包体
- POST安全性比GET安全性高



### HTTP协议的版本

#### HTTP/1.0

HTTP 1.0默认使用短连接，即浏览器的每次请求都需要与服务器建立TCP连接，服务器完成请求处理后立即断开TCP连接。这样导致连接无法复用，耗费资源和性能。如果需要在HTTP1.0中使用长连接，需要添加请求头 Connection: Keep-Alive。

#### HTTP/1.1

HTTP 1.1默认使用长连接。

HTTP 1.1采用分块传输的机制，即产生一块数据，就发送一块。而不是等待所有操作完成后才统一返回数据。

#### HTTP/2.0

采用多路复用的方式，加快数据传输速度。

启用头部压缩。当我们不断地从同一个客户端访问服务器时，有很多重复的数据比如 cookie 数据，会在请求头上反复发送，增加带宽的使用以及延迟。为了解决这个问题，HTTP/2 引入了头压缩。所有头信息都会放在一张表里面，由客户端和服务器共同维护，随后的请求中省略任何重复的标题，使用一个索引号，服务端根据索引号从维护的表中引用它们。

### HTTPS介绍

HTTPS是以安全为目标的HTTP通道，简单讲是HTTP的安全版。
HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。
HTTPS协议使用的是443端口。

### 二、HTTPS的工作原理



![wKioL1PvZ8uDsC6RAAHgZCg1uV0854.jpg](https://s3.51cto.com/wyfs02/M02/46/39/wKioL1PvZ8uDsC6RAAHgZCg1uV0854.jpg)

首先看看组成HTTPS的协议：HTTP协议和SSL/TLS协议。HTTP协议就不用讲了，而SSL/TLS就是负责加密解密等安全处理的模块，所以HTTPS的核心在SSL/TLS上面。整个通信如下：

1、浏览器发起往服务器的443端口发起请求，请求携带了浏览器支持的加密算法和哈希算法。

2、服务器收到请求，选择浏览器支持的加密算法和哈希算法。

3、服务器下将数字证书返回给浏览器，这里的数字证书可以是向某个可靠机构申请的，也可以是自制的。

4、浏览器进入数字证书认证环节，这一部分是浏览器内置的TLS完成的：

4.1 首先浏览器会从内置的证书列表中索引，找到服务器下发证书对应的机构，如果没有找到，此时就会提示用户该证书是不是由权威机构颁发，是不可信任的。如果查到了对应的机构，则取出该机构颁发的公钥。

4.2 用机构的证书公钥解密得到证书的内容和证书签名，内容包括网站的网址、网站的公钥、证书的有效期等。浏览器会先验证证书签名的合法性（验证过程类似上面Bob和Susan的通信）。签名通过后，浏览器验证证书记录的网址是否和当前网址是一致的，不一致会提示用户。如果网址一致会检查证书有效期，证书过期了也会提示用户。这些都通过认证时，浏览器就可以安全使用证书中的网站公钥了。

4.3 浏览器生成一个随机数R，并使用网站公钥对R进行加密。

5、浏览器将加密的R传送给服务器。

6、服务器用自己的私钥解密得到R。

7、服务器以R为密钥使用了**对称加密算法**加密网页内容并传输给浏览器。

8、浏览器以R为密钥使用之前约定好的解密算法获取网页内容。

以共享密钥方式加密时必须将密钥也发给对方。安全转交密钥就需要使用非对称加密算法对密钥进行加密。



对称加密：即通信的双方都使用同一个秘钥进行加解密

非对称加密：

1. 私钥 + 公钥= 密钥对
2. 即用私钥加密的数据,只有对应的公钥才能解密,用公钥加密的数据,只有对应的私钥才能解密



为什么不直接用非对称算法：非对称加密的速度慢

(1) 先生成一个对称加密算法的密钥,用RSA的方式先安全的发给对方  
(2) 随后就不再用RSA了,只用这个对称加密的密钥来互相通信



## Cookie

### Cookie的介绍

由于HTTP协议是无状态的，服务器端无法知道每次用户请求的区别。这时就需要使用Cookie技术保存用户的状态信息。

Cookie是一小段K-V键值对形式的字符串。当浏览器第一次访问Web服务器时，Web服务器会创建Cookie并返回给浏览器，之后浏览器将Cookie存储在用户本地。这样当浏览器再次向该Web服务器发送请求时就会附带这些Cookie，Web服务器就可以使用这些Cookie来识别不同的用户。

### Cookie常用属性

```
name ：一个唯一确定cookie的名称，不区分大小写，cookie的名字必须是经过URL编码的。
value：存储在cookie中的字符串值，必须经过被URL编码
domain：即cookie所属的域。Cookie是不可跨域名的，一个域名下的cookie不会被提交到其他域名。
expires：即cookie的有效期。
max-age：即cookie的最大生存时间，以秒为单位。
```

### Cookie的缺陷

1. 每个域的cookie总数是有限的，不同浏览器之间各有不同。
2. Cookie会被附加在每个HTTP请求中，所以无形中增加了流量。
3. 由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题，除非用HTTPS。
4. Cookie的大小限制在4KB左右，对于复杂的存储需求来说是不够用的。

## Session

### Session的介绍

由于Cookie存在各种缺陷，服务器端采用Session技术来保存用户的状态信息，Session指的是服务器端为客户端所开辟的存储空间。

当浏览器第一次访问Web服务器时，Web服务器会在内部创建一个Session保存用户的状态信息，并将该Session的Id保存在Cookie中返回给浏览器。这样当浏览器再次向该Web服务器发送请求时就会附带保存了SessionId的cookie，Web服务器就可以根据SessionId获取保存在服务器内的浏览器对应的Session。

### 分布式集群中的Session共享

